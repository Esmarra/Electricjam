From: <Saved by Microsoft Internet Explorer 5>
Subject: Beej's Guide to Network Programming Using Internet Sockets
Date: Mon, 18 Dec 2006 14:57:58 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0000_01C722B4.E82699D0"
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.2962

This is a multi-part message in MIME format.

------=_NextPart_000_0000_01C722B4.E82699D0
Content-Type: text/html;
	charset="Windows-1252"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- HTML generated by Beej's bgconv Python script =
--><HTML><HEAD><TITLE>Beej's Guide to Network Programming Using Internet =
Sockets</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dwindows-1252"><LINK=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.css" =
type=3Dtext/css=20
rel=3Dstylesheet>
<META content=3D"MSHTML 6.00.2900.2963" name=3DGENERATOR></HEAD>
<BODY bgColor=3D#ffffff>
<P>
<CENTER>
<H1>Beej's Guide to Network Programming Using Internet =
Sockets</H1></CENTER>
<P>
<P>
<CENTER><I><B>Brian "Beej" Hall</B></I></CENTER>
<P></P>
<P>
<CENTER><I><A href=3D"mailto:beej@beej.us">beej@beej.us</A></I></CENTER>
<P></P><!-- =0A=
	History:=0A=
=0A=
	2.3.2:		socket man page=0A=
	2.3.3:		sockaddr_in man page=0A=
	2.3.4:		bind, listen man page=0A=
	2.3.5:		connect man page=0A=
	2.3.6:		listen, perror man page=0A=
	2.3.7:		errno man page=0A=
	2.3.8:		htonl etc man page=0A=
	2.3.9:		close man page, expanded man page leader=0A=
	2.3.10:		inet_ntoa, setsockopt man pages=0A=
	2.3.11:		getpeername man page=0A=
	2.3.12:		send/sendto man pages=0A=
	2.3.13:		shutdown man pages=0A=
	2.3.14:		gethostname man pages, fix inet_aton links=0A=
	2.3.15:		fcntl man page=0A=
	2.3.16:		recv/recvfrom man page=0A=
	2.3.17:		gethostbyname/gethostbyaddr man page=0A=
	2.3.18:		changed GET / to GET / HTTP/1.0=0A=
	2.3.19:		added select() man page=0A=
	2.3.20:		added poll() man page=0A=
	2.3.21:		section on NAT and reserved networks=0A=
	2.3.22:		typo fixes in sects "man" and "privnet"=0A=
	2.3.23:		added broadcast packets section=0A=
	 -->
<P>
<CENTER>Version 2.3.23</CENTER>
<P></P>
<P>
<CENTER>November 5, 2005</CENTER>
<P></P>
<P>
<CENTER><SMALL>Copyright =A9 2005 Brian "Beej Jorgensen" =
Hall</SMALL></CENTER>
<P></P>
<DIV id=3Dadsense><TD valign=3D"top" align=3D"right">
<SCRIPT type=3Dtext/javascript><!--=0A=
google_ad_client =3D "pub-8191228291510015";=0A=
google_ad_width =3D 160;=0A=
google_ad_height =3D 600;=0A=
google_ad_format =3D "160x600_as";=0A=
google_ad_type =3D "text";=0A=
google_ad_channel =3D"";=0A=
google_color_border =3D "336699";=0A=
google_color_bg =3D "FFFFFF";=0A=
google_color_link =3D "0000FF";=0A=
google_color_url =3D "008000";=0A=
google_color_text =3D "000000";=0A=
//--></SCRIPT>

<SCRIPT src=3D"" type=3Dtext/javascript>=0A=
</SCRIPT>
</TD></TR></TABLE></DIV>
<H2>Contents</H2>
<DL>
  <DT>1. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#intro">In=
tro</A>=20

  <DD>1.1. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#audience"=
>Audience</A>=20

  <DD>1.2. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#platform"=
>Platform=20
  and Compiler</A>=20
  <DD>1.3. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#homepage"=
>Official=20
  Homepage</A>=20
  <DD>1.4. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#solaris">=
Note=20
  for Solaris/SunOS Programmers</A>=20
  <DD>1.5. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#windows">=
Note=20
  for Windows Programmers</A>=20
  <DD>1.6. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#emailpoli=
cy">Email=20
  Policy</A>=20
  <DD>1.7. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#mirroring=
">Mirroring</A>=20

  <DD>1.8. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#xlate">No=
te for=20
  Translators</A>=20
  <DD>1.9. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#copyright=
">Copyright=20
  and Distribution</A>=20
  <P></P>
  <DT>2. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#theory">W=
hat is=20
  a socket?</A>=20
  <DD>2.1. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#twotypes"=
>Two=20
  Types of Internet Sockets</A>=20
  <DD>2.2. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#lowlevel"=
>Low=20
  level Nonsense and Network Theory</A>=20
  <P></P>
  <DT>3. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#structs">=
<TT>struct</TT>s=20
  and Data Handling</A>=20
  <DD>3.1. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#convert">=
Convert=20
  the Natives!</A>=20
  <DD>3.2. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#ipaddr">I=
P=20
  Addresses and How to Deal With Them</A>=20
  <P></P>
  <DT>4. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#syscalls"=
>System=20
  Calls or Bust</A>=20
  <DD>4.1. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#socket"><=
TT>socket()</TT>--Get=20
  the File Descriptor!</A>=20
  <DD>4.2. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#bind"><TT=
>bind()</TT>--What=20
  port am I on?</A>=20
  <DD>4.3. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#connect">=
<TT>connect()</TT>--Hey,=20
  you!</A>=20
  <DD>4.4. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#listen"><=
TT>listen()</TT>--Will=20
  somebody please call me?</A>=20
  <DD>4.5. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#accept"><=
TT>accept()</TT>--"Thank=20
  you for calling port 3490."</A>=20
  <DD>4.6. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendrecv"=
><TT>send()</TT>=20
  and <TT>recv()</TT>--Talk to me, baby!</A>=20
  <DD>4.7. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendtorec=
v"><TT>sendto()</TT>=20
  and <TT>recvfrom()</TT>--Talk to me, DGRAM-style</A>=20
  <DD>4.8. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#closedown=
"><TT>close()</TT>=20
  and <TT>shutdown()</TT>--Get outta my face!</A>=20
  <DD>4.9. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#getpeerna=
me"><TT>getpeername()</TT>--Who=20
  are you?</A>=20
  <DD>4.10. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#gethostna=
me"><TT>gethostname()</TT>--Who=20
  am I?</A>=20
  <DD>4.11. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#dns">DNS-=
-You=20
  say "whitehouse.gov", I say "63.161.169.137"</A>=20
  <P></P>
  <DT>5. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#clientser=
ver">Client-Server=20
  Background</A>=20
  <DD>5.1. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#simpleser=
ver">A=20
  Simple Stream Server</A>=20
  <DD>5.2. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#simplecli=
ent">A=20
  Simple Stream Client</A>=20
  <DD>5.3. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#datagram"=
>Datagram=20
  Sockets</A>=20
  <P></P>
  <DT>6. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#advanced"=
>Slightly=20
  Advanced Techniques</A>=20
  <DD>6.1. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#blocking"=
>Blocking</A>=20

  <DD>6.2. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#select"><=
TT>select()</TT>--Synchronous=20
  I/O Multiplexing</A>=20
  <DD>6.3. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendall">=
Handling=20
  Partial <TT>send()</TT>s</A>=20
  <DD>6.4. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sonofdata=
encap">Son=20
  of Data Encapsulation</A>=20
  <DD>6.5. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#broadcast=
">Broadcast=20
  Packets--Hello, World!</A>=20
  <P></P>
  <DT>7. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#faq">Comm=
on=20
  Questions</A>=20
  <P></P>
  <DT>8. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#man">Man =

  Pages</A>=20
  <DD>8.1. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#acceptman=
"><TT>accept()</TT></A>=20

  <DD>8.2. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#bindman">=
<TT>bind()</TT></A>=20

  <DD>8.3. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#connectma=
n"><TT>connect()</TT></A>=20

  <DD>8.4. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#closeman"=
><TT>close()</TT></A>=20

  <DD>8.5. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#gethostna=
meman"><TT>gethostname()</TT></A>=20

  <DD>8.6. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#gethostby=
nameman"><TT>gethostbyname()</TT>,=20
  <TT>gethostbyaddr()</TT></A>=20
  <DD>8.7. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#getpeerna=
meman"><TT>getpeername()</TT></A>=20

  <DD>8.8. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#errnoman"=
><B><TT>errno</TT></B></A>=20

  <DD>8.9. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#fcntlman"=
><TT>fcntl()</TT></A>=20

  <DD>8.10. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#htonsman"=
><TT>htons()</TT>,=20
  <TT>htonl()</TT>, <TT>ntohs()</TT>, <TT>ntohl()</TT></A>=20
  <DD>8.11. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#inet_ntoa=
man"><TT>inet_ntoa()</TT>,=20
  <TT>inet_aton()</TT></A>=20
  <DD>8.12. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#listenman=
"><TT>listen()</TT></A>=20

  <DD>8.13. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#perrorman=
"><TT>perror()</TT>,=20
  <TT>strerror()</TT></A>=20
  <DD>8.14. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#pollman">=
<TT>poll()</TT></A>=20

  <DD>8.15. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#recvman">=
<TT>recv()</TT>,=20
  <TT>recvfrom()</TT></A>=20
  <DD>8.16. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#selectman=
"><TT>select()</TT></A>=20

  <DD>8.17. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#setsockop=
tman"><TT>setsockopt()</TT>,=20
  <TT>getsockopt()</TT></A>=20
  <DD>8.18. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendman">=
<TT>send()</TT>,=20
  <TT>sendto()</TT></A>=20
  <DD>8.19. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#shutdownm=
an"><TT>shutdown()</TT></A>=20

  <DD>8.20. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#socketman=
"><TT>socket()</TT></A>=20

  <DD>8.21. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sockaddr_=
inman"><TT>struct=20
  sockaddr_in</TT>, <TT>struct in_addr</TT></A>=20
  <P></P>
  <DT>9. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#reference=
">More=20
  References</A>=20
  <DD>9.1. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#books">Bo=
oks</A>=20

  <DD>9.2. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#webref">W=
eb=20
  References</A>=20
  <DD>9.3. <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#rfcs">RFC=
s</A>=20
  <P></P></DD></DL>
<P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Introduction  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<HR>

<H2>1. <A name=3Dintro>Intro</A></H2>
<P></P>
<P>Hey! Socket programming got you down? Is this stuff just a little too =

difficult to figure out from the <B><TT>man</TT></B> pages? You want to =
do cool=20
Internet programming, but you don't have time to wade through a gob of=20
<TT>struct</TT>s trying to figure out if you have to call =
<TT>bind()</TT> before=20
you <TT>connect()</TT>, etc., etc.</P>
<P>Well, guess what! I've already done this nasty business, and I'm =
dying to=20
share the information with everyone! You've come to the right place. =
This=20
document should give the average competent C programmer the edge s/he =
needs to=20
get a grip on this networking noise.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Audience  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>1.1. <A name=3Daudience>Audience</A></H3>
<P></P>
<P>This document has been written as a tutorial, not a reference. It is =
probably=20
at its best when read by individuals who are just starting out with =
socket=20
programming and are looking for a foothold. It is certainly not the=20
<I>complete</I> guide to sockets programming, by any means.</P>
<P>Hopefully, though, it'll be just enough for those man pages to start =
making=20
sense... <TT>:-)</TT></P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Platform and Compiler  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>1.2. <A name=3Dplatform>Platform and Compiler</A></H3>
<P></P>
<P>The code contained within this document was compiled on a Linux PC =
using=20
Gnu's <B><TT>gcc</TT></B> compiler. It should, however, build on just =
about any=20
platform that uses <B><TT>gcc</TT></B>. Naturally, this doesn't apply if =
you're=20
programming for Windows--see the <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#windows">=
section=20
on Windows programming</A>, below.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Homepage  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>1.3. <A name=3Dhomepage>Official Homepage</A></H3>
<P></P>
<P>This official location of this document is <A=20
href=3D"http://beej.us/guide/bgnet/">http://beej.us/guide/bgnet/</A>.</P>=
<!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Solaris and SunOS  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>1.4. <A name=3Dsolaris>Note for Solaris/SunOS Programmers</A></H3>
<P></P>
<P>When compiling for Solaris or SunOS, you need to specify some extra=20
command-line switches for linking in the proper libraries. In order to =
do this,=20
simply add "<TT>-lnsl -lsocket -lresolv</TT>" to the end of the compile =
command,=20
like so:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>$ cc -o server server.c -lnsl -lsocket =
-lresolv
</PRE></TR></TBODY></TABLE></P>
<P>If you still get errors, you could try further adding a =
"<TT>-lxnet</TT>" to=20
the end of that command line. I don't know what that does, exactly, but =
some=20
people seem to need it.</P>
<P>Another place that you might find problems is in the call to=20
<TT>setsockopt()</TT>. The prototype differs from that on my Linux box, =
so=20
instead of:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>int yes=3D1;
</PRE></TR></TBODY></TABLE></P>
<P>enter this:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>char yes=3D'1';
</PRE></TR></TBODY></TABLE></P>
<P>As I don't have a Sun box, I haven't tested any of the above=20
information--it's just what people have told me through email.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Windows  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>1.5. <A name=3Dwindows>Note for Windows Programmers</A></H3>
<P></P>
<P>I have a particular dislike for Windows, and encourage you to try =
Linux, BSD,=20
or Unix instead. That being said, you can still use this stuff under=20
Windows.</P>
<P>First, ignore pretty much all of the system header files I mention in =
here.=20
All you need to include is:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;winsock.h&gt;
</PRE></TR></TBODY></TABLE></P>
<P>Wait! You also have to make a call to <TT>WSAStartup()</TT> before =
doing=20
anything else with the sockets library. The code to do that looks =
something like=20
this:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;winsock.h&gt;

{
    WSADATA wsaData;   // if this doesn't work
    //WSAData wsaData; // then try this instead

    if (WSAStartup(MAKEWORD(1, 1), &amp;wsaData) !=3D 0) {
        fprintf(stderr, "WSAStartup failed.\n");
        exit(1);
    }
</PRE></TR></TBODY></TABLE></P>
<P>You also have to tell your compiler to link in the Winsock library, =
usually=20
called <I><TT>wsock32.lib</TT></I> or <I><TT>winsock32.lib</TT></I> or =
somesuch.=20
Under VC++, this can be done through the <TT>Project</TT> menu, under=20
<TT>Settings...</TT>. Click the <TT>Link</TT> tab, and look for the box =
titled=20
"Object/library modules". Add "wsock32.lib" to that list.</P>
<P>Or so I hear.</P>
<P>Finally, you need to call <TT>WSACleanup()</TT> when you're all =
through with=20
the sockets library. See your online help for details.</P>
<P>Once you do that, the rest of the examples in this tutorial should =
generally=20
apply, with a few exceptions. For one thing, you can't use =
<TT>close()</TT> to=20
close a socket--you need to use <TT>closesocket()</TT>, instead. Also,=20
<TT>select()</TT> only works with socket descriptors, not file =
descriptors (like=20
<B><TT>0</TT></B> for <TT>stdin</TT>).</P>
<P>There is also a socket class that you can use, <TT>CSocket</TT>. =
Check your=20
compilers help pages for more information.</P>
<P>To get more information about Winsock, read the <A=20
href=3D"http://tangentsoft.net/wskfaq/">Winsock FAQ</A> and go from =
there.</P>
<P>Finally, I hear that Windows has no <TT>fork()</TT> system call which =
is,=20
unfortunately, used in some of my examples. Maybe you have to link in a =
POSIX=20
library or something to get it to work, or you can use =
<TT>CreateProcess()</TT>=20
instead. <TT>fork()</TT> takes no arguments, and =
<TT>CreateProcess()</TT> takes=20
about 48 billion arguments. If you're not up to that, the=20
<TT>CreateThread()</TT> is a little easier to digest...unfortunately a=20
discussion about multithreading is beyond the scope of this document. I =
can only=20
talk about so much, you know!</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Email policy  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>1.6. <A name=3Demailpolicy>Email Policy</A></H3>
<P></P>
<P>I'm generally available to help out with email questions so feel free =
to=20
write in, but I can't guarantee a response. I lead a pretty busy life =
and there=20
are times when I just can't answer a question you have. When that's the =
case, I=20
usually just delete the message. It's nothing personal; I just won't =
ever have=20
the time to give the detailed answer you require.</P>
<P>As a rule, the more complex the question, the less likely I am to =
respond. If=20
you can narrow down your question before mailing it and be sure to =
include any=20
pertinent information (like platform, compiler, error messages you're =
getting,=20
and anything else you think might help me troubleshoot), you're much =
more likely=20
to get a response. For more pointers, read ESR's document, <A=20
href=3D"http://www.catb.org/~esr/faqs/smart-questions.html">How To Ask =
Questions=20
The Smart Way</A>.</P>
<P>If you don't get a response, hack on it some more, try to find the =
answer,=20
and if it's still elusive, then write me again with the information =
you've found=20
and hopefully it will be enough for me to help out.</P>
<P>Now that I've badgered you about how to write and not write me, I'd =
just like=20
to let you know that I <I>fully</I> appreciate all the praise the guide =
has=20
received over the years. It's a real morale boost, and it gladdens me to =
hear=20
that it is being used for good! <TT>:-)</TT> Thank you!</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Mirroring  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>1.7. <A name=3Dmirroring>Mirroring</A></H3>
<P></P>
<P>You are more than welcome to mirror this site, whether publically or=20
privately. If you publically mirror the site and want me to link to it =
from the=20
main page, drop me a line at <TT><A=20
href=3D"mailto:beej@beej.us">beej@beej.us</A></TT>.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Translators  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>1.8. <A name=3Dxlate>Note for Translators</A></H3>
<P></P>
<P>If you want to translate the guide into another language, write me at =
<TT><A=20
href=3D"mailto:beej@beej.us">beej@beej.us</A></TT> and I'll link to your =

translation from the main page.</P>
<P>Feel free to add your name and email address to the translation.</P>
<P>Sorry, but due to space constraints, I cannot host the translations=20
myself.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Copyright  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>1.9. <A name=3Dcopyright>Copyright and Distribution</A></H3>
<P></P>
<P>Beej's Guide to Network Programming is Copyright =A9 2005 Brian =
"Beej"=20
Hall.</P>
<P>This guide may be freely reprinted in any medium provided that its =
content is=20
not altered, it is presented in its entirety, and this copyright notice =
remains=20
intact.</P>
<P>Educators are especially encouraged to recommend or supply copies of =
this=20
guide to their students.</P>
<P>This guide may be freely translated into any language, provided the=20
translation is accurate, and the guide is reprinted in its entirety. The =

translation may also include the name and contact information for the=20
translator.</P>
<P>The C source code presented in this document is hereby granted to the =
public=20
domain.</P>
<P>Contact <TT><A href=3D"mailto:beej@beej.us">beej@beej.us</A></TT> for =
more=20
information.</P><!--  /Introduction  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  What is a socket?  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<HR>

<H2>2. <A name=3Dtheory>What is a socket?</A></H2>
<P></P>
<P>You hear talk of "sockets" all the time, and perhaps you are =
wondering just=20
what they are exactly. Well, they're this: a way to speak to other =
programs=20
using standard Unix file descriptors.</P>
<P>What?</P>
<P>Ok--you may have heard some Unix hacker state, "Jeez, =
<I>everything</I> in=20
Unix is a file!" What that person may have been talking about is the =
fact that=20
when Unix programs do any sort of I/O, they do it by reading or writing =
to a=20
file descriptor. A file descriptor is simply an integer associated with =
an open=20
file. But (and here's the catch), that file can be a network connection, =
a FIFO,=20
a pipe, a terminal, a real on-the-disk file, or just about anything =
else.=20
Everything in Unix <I>is</I> a file! So when you want to communicate =
with=20
another program over the Internet you're gonna do it through a file =
descriptor,=20
you'd better believe it.</P>
<P>"Where do I get this file descriptor for network communication, Mr.=20
Smarty-Pants?" is probably the last question on your mind right now, but =
I'm=20
going to answer it anyway: You make a call to the <TT>socket()</TT> =
system=20
routine. It returns the socket descriptor, and you communicate through =
it using=20
the specialized <TT>send()</TT> and <TT>recv()</TT> (<B><TT><A=20
href=3D"http://man.linuxquestions.org/index.php?query=3Dsend&amp;section=3D=
2&amp;type=3D2">man=20
send</A></TT></B>, <B><TT><A=20
href=3D"http://man.linuxquestions.org/index.php?query=3Drecv&amp;section=3D=
2&amp;type=3D2">man=20
recv</A></TT></B>) socket calls.</P>
<P>"But, hey!" you might be exclaiming right about now. "If it's a file=20
descriptor, why in the name of Neptune can't I just use the normal=20
<TT>read()</TT> and <TT>write()</TT> calls to communicate through the =
socket?"=20
The short answer is, "You can!" The longer answer is, "You can, but=20
<TT>send()</TT> and <TT>recv()</TT> offer much greater control over your =
data=20
transmission."</P>
<P>What next? How about this: there are all kinds of sockets. There are =
DARPA=20
Internet addresses (Internet Sockets), path names on a local node (Unix=20
Sockets), CCITT X.25 addresses (X.25 Sockets that you can safely =
ignore), and=20
probably many others depending on which Unix flavor you run. This =
document deals=20
only with the first: Internet Sockets.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Two Types of Internet Sockets  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>2.1. <A name=3Dtwotypes>Two Types of Internet Sockets</A></H3>
<P></P>
<P>What's this? There are two types of Internet sockets? Yes. Well, no. =
I'm=20
lying. There are more, but I didn't want to scare you. I'm only going to =
talk=20
about two types here. Except for this sentence, where I'm going to tell =
you that=20
"Raw Sockets" are also very powerful and you should look them up.</P>
<P>All right, already. What are the two types? One is "Stream Sockets"; =
the=20
other is "Datagram Sockets", which may hereafter be referred to as=20
"<B><TT>SOCK_STREAM</TT></B>" and "<B><TT>SOCK_DGRAM</TT></B>", =
respectively.=20
Datagram sockets are sometimes called "connectionless sockets". (Though =
they can=20
be <TT>connect()</TT>'d if you really want. See <TT><A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#connect">=
connect()</A></TT>,=20
below.)</P>
<P>Stream sockets are reliable two-way connected communication streams. =
If you=20
output two items into the socket in the order "1, 2", they will arrive =
in the=20
order "1, 2" at the opposite end. They will also be error free. Any =
errors you=20
do encounter are figments of your own deranged mind, and are not to be =
discussed=20
here.</P>
<P>What uses stream sockets? Well, you may have heard of the=20
<B><TT>telnet</TT></B> application, yes? It uses stream sockets. All the =

characters you type need to arrive in the same order you type them, =
right? Also,=20
web browsers use the HTTP protocol which uses stream sockets to get =
pages.=20
Indeed, if you telnet to a web site on port 80, and type "<TT>GET /=20
HTTP/1.0</TT>" and hit RETURN twice, it'll dump the HTML back at =
you!</P>
<P>How do stream sockets achieve this high level of data transmission =
quality?=20
They use a protocol called "The Transmission Control Protocol", =
otherwise known=20
as "TCP" (see <A =
href=3D"http://www.rfc-editor.org/rfc/rfc793.txt">RFC-793</A> for=20
extremely detailed info on TCP.) TCP makes sure your data arrives =
sequentially=20
and error-free. You may have heard "TCP" before as the better half of =
"TCP/IP"=20
where "IP" stands for "Internet Protocol" (see <A=20
href=3D"http://www.rfc-editor.org/rfc/rfc791.txt">RFC-791</A>.) IP deals =
primarily=20
with Internet routing and is not generally responsible for data =
integrity.</P>
<P>Cool. What about Datagram sockets? Why are they called =
connectionless? What=20
is the deal, here, anyway? Why are they unreliable? Well, here are some =
facts:=20
if you send a datagram, it may arrive. It may arrive out of order. If it =

arrives, the data within the packet will be error-free.</P>
<P>Datagram sockets also use IP for routing, but they don't use TCP; =
they use=20
the "User Datagram Protocol", or "UDP" (see <A=20
href=3D"http://www.rfc-editor.org/rfc/rfc768.txt">RFC-768</A>.)</P>
<P>Why are they connectionless? Well, basically, it's because you don't =
have to=20
maintain an open connection as you do with stream sockets. You just =
build a=20
packet, slap an IP header on it with destination information, and send =
it out.=20
No connection needed. They are generally used for packet-by-packet =
transfers of=20
information. Sample applications: <B><TT>tftp</TT></B>, =
<B><TT>bootp</TT></B>,=20
etc.</P>
<P>"Enough!" you may scream. "How do these programs even work if =
datagrams might=20
get lost?!" Well, my human friend, each has it's own protocol on top of =
UDP. For=20
example, the tftp protocol says that for each packet that gets sent, the =

recipient has to send back a packet that says, "I got it!" (an "ACK" =
packet.) If=20
the sender of the original packet gets no reply in, say, five seconds, =
he'll=20
re-transmit the packet until he finally gets an ACK. This acknowledgment =

procedure is very important when implementing <B><TT>SOCK_DGRAM</TT></B> =

applications.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Two Types of Internet Sockets  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>2.2. <A name=3Dlowlevel>Low level Nonsense and Network =
Theory</A></H3>
<P></P>
<P>Since I just mentioned layering of protocols, it's time to talk about =
how=20
networks really work, and to show some examples of how=20
<B><TT>SOCK_DGRAM</TT></B> packets are built. Practically, you can =
probably skip=20
this section. It's good background, however.</P>
<HR>

<CENTER><IMG alt=3DNone=20
src=3D"http://beej.us/guide/bgnet/output/htmlsingle/dataencap.png">=20
<P><B>Data Encapsulation.</B></P></CENTER>
<HR>

<P>Hey, kids, it's time to learn about <I><A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#figure1">=
Data=20
Encapsulation</A></I>! This is very very important. It's so important =
that you=20
might just learn about it if you take the networks course here at Chico =
State=20
<TT>;-)</TT>. Basically, it says this: a packet is born, the packet is =
wrapped=20
("encapsulated") in a header (and rarely a footer) by the first protocol =
(say,=20
the TFTP protocol), then the whole thing (TFTP header included) is =
encapsulated=20
again by the next protocol (say, UDP), then again by the next (IP), then =
again=20
by the final protocol on the hardware (physical) layer (say, =
Ethernet).</P>
<P>When another computer receives the packet, the hardware strips the =
Ethernet=20
header, the kernel strips the IP and UDP headers, the TFTP program =
strips the=20
TFTP header, and it finally has the data.</P>
<P>Now I can finally talk about the infamous <I>Layered Network =
Model</I>. This=20
Network Model describes a system of network functionality that has many=20
advantages over other models. For instance, you can write sockets =
programs that=20
are exactly the same without caring how the data is physically =
transmitted=20
(serial, thin Ethernet, AUI, whatever) because programs on lower levels =
deal=20
with it for you. The actual network hardware and topology is transparent =
to the=20
socket programmer.</P>
<P>Without any further ado, I'll present the layers of the full-blown =
model.=20
Remember this for network class exams:</P>
<UL>
  <LI>
  <P>Application</P>
  <LI>
  <P>Presentation</P>
  <LI>
  <P>Session</P>
  <LI>
  <P>Transport</P>
  <LI>
  <P>Network</P>
  <LI>
  <P>Data Link</P>
  <LI>
  <P>Physical</P></LI></UL>
<P>The Physical Layer is the hardware (serial, Ethernet, etc.). The =
Application=20
Layer is just about as far from the physical layer as you can =
imagine--it's the=20
place where users interact with the network.</P>
<P>Now, this model is so general you could probably use it as an =
automobile=20
repair guide if you really wanted to. A layered model more consistent =
with Unix=20
might be:</P>
<UL>
  <LI>
  <P>Application Layer (<I>telnet, ftp, etc.</I>)</P>
  <LI>
  <P>Host-to-Host Transport Layer (<I>TCP, UDP</I>)</P>
  <LI>
  <P>Internet Layer (<I>IP and routing</I>)</P>
  <LI>
  <P>Network Access Layer (<I>Ethernet, ATM, or =
whatever</I>)</P></LI></UL>
<P>At this point in time, you can probably see how these layers =
correspond to=20
the encapsulation of the original data.</P>
<P>See how much work there is in building a simple packet? Jeez! And you =
have to=20
type in the packet headers yourself using "<B><TT>cat</TT></B>"! Just =
kidding.=20
All you have to do for stream sockets is <TT>send()</TT> the data out. =
All you=20
have to do for datagram sockets is encapsulate the packet in the method =
of your=20
choosing and <TT>sendto()</TT> it out. The kernel builds the Transport =
Layer and=20
Internet Layer on for you and the hardware does the Network Access =
Layer. Ah,=20
modern technology.</P>
<P>So ends our brief foray into network theory. Oh yes, I forgot to tell =
you=20
everything I wanted to say about routing: nothing! That's right, I'm not =
going=20
to talk about it at all. The router strips the packet to the IP header, =
consults=20
its routing table, blah blah blah. Check out the <A=20
href=3D"http://www.rfc-editor.org/rfc/rfc791.txt">IP RFC</A> if you =
really really=20
care. If you never learn about it, well, you'll live.</P><!--  /What is =
a socket?  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  structs  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<HR>

<H2>3. <A name=3Dstructs><TT>struct</TT>s and Data Handling</A></H2>
<P></P>
<P>Well, we're finally here. It's time to talk about programming. In =
this=20
section, I'll cover various data types used by the sockets interface, =
since some=20
of them are a real bear to figure out.</P>
<P>First the easy one: a socket descriptor. A socket descriptor is the =
following=20
type:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>int
</PRE></TR></TBODY></TABLE></P>
<P>Just a regular <TT>int</TT>.</P>
<P>Things get weird from here, so just read through and bear with me. =
Know this:=20
there are two byte orderings: most significant byte (sometimes called an =

"octet") first, or least significant byte first. The former is called =
"Network=20
Byte Order". Some machines store their numbers internally in Network =
Byte Order,=20
some don't. When I say something has to be in Network Byte Order, you =
have to=20
call a function (such as <TT>htons()</TT>) to change it from "Host Byte =
Order".=20
If I don't say "Network Byte Order", then you must leave the value in =
Host Byte=20
Order.</P>
<P>(For the curious, "Network Byte Order" is also known as "Big-Endian =
Byte=20
Order".)</P>
<P>My First Struct<SUPER><SMALL>TM</SMALL></SUPER>--<TT>struct =
sockaddr</TT>.=20
This structure holds socket address information for many types of =
sockets:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>struct sockaddr {
    unsigned short    sa_family;    // address family, AF_xxx
    char              sa_data[14];  // 14 bytes of protocol address
};=20
</PRE></TR></TBODY></TABLE></P>
<P><I><TT>sa_family</TT></I> can be a variety of things, but it'll be=20
<B><TT>AF_INET</TT></B> for everything we do in this document.=20
<I><TT>sa_data</TT></I> contains a destination address and port number =
for the=20
socket. This is rather unwieldy since you don't want to tediously pack =
the=20
address in the <I><TT>sa_data</TT></I> by hand.</P>
<P>To deal with <TT>struct sockaddr</TT>, programmers created a parallel =

structure: <TT>struct sockaddr_in</TT> ("in" for "Internet".)</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>struct sockaddr_in {
    short int          sin_family;  // Address family
    unsigned short int sin_port;    // Port number
    struct in_addr     sin_addr;    // Internet address
    unsigned char      sin_zero[8]; // Same size as struct sockaddr
};=20
</PRE></TR></TBODY></TABLE></P>
<P>This structure makes it easy to reference elements of the socket =
address.=20
Note that <I><TT>sin_zero</TT></I> (which is included to pad the =
structure to=20
the length of a <TT>struct sockaddr</TT>) should be set to all zeros =
with the=20
function <TT>memset()</TT>. Also, and this is the <I>important</I> bit, =
a=20
pointer to a <TT>struct sockaddr_in</TT> can be cast to a pointer to a=20
<TT>struct sockaddr</TT> and vice-versa. So even though =
<TT>connect()</TT> wants=20
a <TT>struct sockaddr*</TT>, you can still use a <TT>struct =
sockaddr_in</TT> and=20
cast it at the last minute! Also, notice that <I><TT>sin_family</TT></I> =

corresponds to <I><TT>sa_family</TT></I> in a <TT>struct sockaddr</TT> =
and=20
should be set to "<B><TT>AF_INET</TT></B>". Finally, the=20
<I><TT>sin_port</TT></I> and <I><TT>sin_addr</TT></I> must be in =
<I>Network Byte=20
Order</I>!</P>
<P>"But," you object, "how can the entire structure, <TT>struct in_addr=20
sin_addr</TT>, be in Network Byte Order?" This question requires careful =

examination of the structure <TT>struct in_addr</TT>, one of the worst =
unions=20
alive:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>// Internet address (a structure for =
historical reasons)
struct in_addr {
    unsigned long s_addr; // that's a 32-bit long, or 4 bytes
};=20
</PRE></TR></TBODY></TABLE></P>
<P>Well, it <I>used</I> to be a union, but now those days seem to be =
gone. Good=20
riddance. So if you have declared <I><TT>ina</TT></I> to be of type =
<TT>struct=20
sockaddr_in</TT>, then <I><TT>ina.sin_addr.s_addr</TT></I> references =
the 4-byte=20
IP address (in Network Byte Order). Note that even if your system still =
uses the=20
God-awful union for <TT>struct in_addr</TT>, you can still reference the =
4-byte=20
IP address in exactly the same way as I did above (this due to=20
<TT>#define</TT>s.)</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  Convert The Natives  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>3.1. <A name=3Dconvert>Convert the Natives!</A></H3>
<P></P>
<P>We've now been lead right into the next section. There's been too =
much talk=20
about this Network to Host Byte Order conversion--now is the time for=20
action!</P>
<P>All righty. There are two types that you can convert: <TT>short</TT> =
(two=20
bytes) and <TT>long</TT> (four bytes). These functions work for the=20
<TT>unsigned</TT> variations as well. Say you want to convert a =
<TT>short</TT>=20
from Host Byte Order to Network Byte Order. Start with "h" for "host", =
follow it=20
with "to", then "n" for "network", and "s" for "short": h-to-n-s, or=20
<TT>htons()</TT> (read: "Host to Network Short").</P>
<P>It's almost too easy...</P>
<P>You can use every combination of "n", "h", "s", and "l" you want, not =

counting the really stupid ones. For example, there is NOT a =
<TT>stolh()</TT>=20
("Short to Long Host") function--not at this party, anyway. But there =
are:</P>
<UL>
  <LI>
  <P><TT>htons()</TT> -- "Host to Network Short"</P>
  <LI>
  <P><TT>htonl()</TT> -- "Host to Network Long"</P>
  <LI>
  <P><TT>ntohs()</TT> -- "Network to Host Short"</P>
  <LI>
  <P><TT>ntohl()</TT> -- "Network to Host Long"</P></LI></UL>
<P>Now, you may think you're wising up to this. You might think, "What =
do I do=20
if I have to change byte order on a <TT>char</TT>?" Then you might =
think, "Uh,=20
never mind." You might also think that since your 68000 machine already =
uses=20
network byte order, you don't have to call <TT>htonl()</TT> on your IP=20
addresses. You would be right, <I>BUT</I> if you try to port to a =
machine that=20
has reverse network byte order, your program will fail. Be portable! =
This is a=20
Unix world! (As much as Bill Gates would like to think otherwise.) =
Remember: put=20
your bytes in Network Byte Order before you put them on the network.</P>
<P>A final point: why do <I><TT>sin_addr</TT></I> and =
<I><TT>sin_port</TT></I>=20
need to be in Network Byte Order in a <TT>struct sockaddr_in</TT>, but=20
<I><TT>sin_family</TT></I> does not? The answer: =
<I><TT>sin_addr</TT></I> and=20
<I><TT>sin_port</TT></I> get encapsulated in the packet at the IP and =
UDP=20
layers, respectively. Thus, they must be in Network Byte Order. However, =
the=20
<I><TT>sin_family</TT></I> field is only used by the kernel to determine =
what=20
type of address the structure contains, so it must be in Host Byte =
Order. Also,=20
since <I><TT>sin_family</TT></I> does <I>not</I> get sent out on the =
network, it=20
can be in Host Byte Order.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  IP Addresses  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>3.2. <A name=3Dipaddr>IP Addresses and How to Deal With =
Them</A></H3>
<P></P>
<P>Fortunately for you, there are a bunch of functions that allow you to =

manipulate IP addresses. No need to figure them out by hand and stuff =
them in a=20
<TT>long</TT> with the <TT>&lt;&lt;</TT> operator.</P>
<P>First, let's say you have a <TT>struct sockaddr_in ina</TT>, and you =
have an=20
IP address "<TT>10.12.110.57</TT>" that you want to store into it. The =
function=20
you want to use, <TT>inet_addr()</TT>, converts an IP address in=20
numbers-and-dots notation into an unsigned long. The assignment can be =
made as=20
follows:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>ina.sin_addr.s_addr =3D =
inet_addr("10.12.110.57");=20
</PRE></TR></TBODY></TABLE></P>
<P>Notice that <TT>inet_addr()</TT> returns the address in Network Byte =
Order=20
already--you don't have to call <TT>htonl()</TT>. Swell!</P>
<P>Now, the above code snippet isn't very robust because there is no =
error=20
checking. See, <TT>inet_addr()</TT> returns <B><TT>-1</TT></B> on error. =

Remember binary numbers? <B><TT>(unsigned)-1</TT></B> just happens to =
correspond=20
to the IP address <TT>255.255.255.255</TT>! That's the <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#broadcast=
">broadcast</A>=20
address! Wrongo. Remember to do your error checking properly.</P>
<P>Actually, there's a cleaner interface you can use instead of=20
<TT>inet_addr()</TT>: it's called <TT>inet_aton()</TT> ("aton" means =
"ascii to=20
network"):</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

int inet_aton(const char *cp, struct in_addr *inp);=20
</PRE></TR></TBODY></TABLE></P>
<P>And here's a sample usage, while packing a <TT>struct =
sockaddr_in</TT> (this=20
example will make more sense to you when you get to the sections on <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#bind"><TT=
>bind()</TT></A>=20
and <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#connect">=
<TT>connect()</TT></A>.)</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>struct sockaddr_in my_addr;

my_addr.sin_family =3D AF_INET;         // host byte order
my_addr.sin_port =3D htons(MYPORT);     // short, network byte order
inet_aton("10.12.110.57", &amp;(my_addr.sin_addr));
memset(&amp;(my_addr.sin_zero), '\0', 8); // zero the rest of the struct =

</PRE></TR></TBODY></TABLE></P>
<P><TT>inet_aton()</TT>, <I>unlike practically every other =
socket-related=20
function</I>, returns non-zero on success, and zero on failure. And the =
address=20
is passed back in <I><TT>inp</TT></I>.</P>
<P>Unfortunately, not all platforms implement <TT>inet_aton()</TT> so, =
although=20
its use is preferred, the older more common <TT>inet_addr()</TT> is used =
in this=20
guide.</P>
<P>All right, now you can convert string IP addresses to their binary=20
representations. What about the other way around? What if you have a =
<TT>struct=20
in_addr</TT> and you want to print it in numbers-and-dots notation? In =
this=20
case, you'll want to use the function <TT>inet_ntoa()</TT> ("ntoa" means =

"network to ascii") like this:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>printf("%s", inet_ntoa(ina.sin_addr));=20
</PRE></TR></TBODY></TABLE></P>
<P>That will print the IP address. Note that <TT>inet_ntoa()</TT> takes =
a=20
<TT>struct in_addr</TT> as an argument, not a <TT>long</TT>. Also notice =
that it=20
returns a pointer to a char. This points to a statically stored char =
array=20
within <TT>inet_ntoa()</TT> so that each time you call =
<TT>inet_ntoa()</TT> it=20
will overwrite the last IP address you asked for. For example:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>char *a1, *a2;

a1 =3D inet_ntoa(ina1.sin_addr);  // this is 192.168.4.14
a2 =3D inet_ntoa(ina2.sin_addr);  // this is 10.12.110.57
printf("address 1: %s\n",a1);
printf("address 2: %s\n",a2);=20
</PRE></TR></TBODY></TABLE></P>
<P>will print:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>address 1: 10.12.110.57
address 2: 10.12.110.57=20
</PRE></TR></TBODY></TABLE></P>
<P>If you need to save the address, <TT>strcpy()</TT> it to your own =
character=20
array.</P>
<P>That's all on this topic for now. Later, you'll learn to convert a =
string=20
like "whitehouse.gov" into its corresponding IP address (see <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#dns">DNS<=
/A>,=20
below.)</P>
<P>
<H4>3.2.1. <A name=3Dprivnet>Private (Or Disconnected) Networks</A></H4>
<P></P>
<P>Lots of places have a firewall that hides the network from the rest =
of the=20
world for their own protection. And often times, the firewall translates =

"internal" IP addresses to "external" (that everyone else in the world =
knows) IP=20
addresses using a process called <I>Network Address Translation</I>, or =
NAT.</P>
<P>Are you getting nervous yet? "Where's he going with all this weird=20
stuff?"</P>
<P>Well, relax and buy yourself a drink, because as a beginner, you =
don't even=20
have to worry about NAT, since it's done for you transparently. But I =
wanted to=20
talk about the network behind the firewall in case you started getting =
confused=20
by the network numbers you were seeing.</P>
<P>For instance, I have a firewall at home. I have two static IP =
addresses=20
allocated to me by the DSL company, and yet I have seven computers on =
the=20
network. How is this possible? Two computers can't share the same IP =
address, or=20
else the data wouldn't know which one to go to!</P>
<P>The answer is: they don't share the same IP addresses. They are on a =
private=20
network with 24 million IP addresses allocated to it. They are all just =
for me.=20
Well, all for me as far as anyone else is concerned. Here's what's=20
happening:</P>
<P>If I log into a remote computer, it tells me I'm logged in from =
64.81.52.10=20
(not my real IP). But if I ask my local computer what it's IP address =
is, it=20
says 10.0.0.5. Who is translating the IP address from one to the other? =
That's=20
right, the firewall! It's doing NAT!</P>
<P>10.<I>x</I>.<I>x</I>.<I>x</I> is one of a few reserved networks that =
are only=20
to be used either on fully disconnected networks, or on networks that =
are behind=20
firewalls. The details of which private network numbers are available =
for you to=20
use are outlined in <A =
href=3D"ftp://ftp.rfc-editor.org/in-notes/rfc1918.txt">RFC=20
1918</A>, but some common ones you'll see are =
10.<I>x</I>.<I>x</I>.<I>x</I> and=20
192.168.<I>x</I>.<I>x</I>, where <I>x</I> is 0-255, generally. Less =
common is=20
172.<I>y</I>.<I>x</I>.<I>x</I>, where <I>y</I> goes between 16 and =
31.</P>
<P>Networks behind a NATing firewall don't <I>need</I> to be on one of =
these=20
reserved networks, but they commonly are.</P><!--  /structs  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  System Calls  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<HR>

<H2>4. <A name=3Dsyscalls>System Calls or Bust</A></H2>
<P></P>
<P>This is the section where we get into the system calls that allow you =
to=20
access the network functionality of a Unix box. When you call one of =
these=20
functions, the kernel takes over and does all the work for you=20
automagically.</P>
<P>The place most people get stuck around here is what order to call =
these=20
things in. In that, the <B><TT>man</TT></B> pages are no use, as you've =
probably=20
discovered. Well, to help with that dreadful situation, I've tried to =
lay out=20
the system calls in the following sections in <I>exactly</I> =
(approximately) the=20
same order that you'll need to call them in your programs.</P>
<P>That, coupled with a few pieces of sample code here and there, some =
milk and=20
cookies (which I fear you will have to supply yourself), and some raw =
guts and=20
courage, and you'll be beaming data around the Internet like the Son of =
Jon=20
Postel!</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  socket  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.1. <A name=3Dsocket><TT>socket()</TT>--Get the File =
Descriptor!</A></H3>
<P></P>
<P>I guess I can put it off no longer--I have to talk about the=20
<TT>socket()</TT> system call. Here's the breakdown:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);=20
</PRE></TR></TBODY></TABLE></P>
<P>But what are these arguments? First, <I><TT>domain</TT></I> should be =
set to=20
"<B><TT>PF_INET</TT></B>". Next, the <I><TT>type</TT></I> argument tells =
the=20
kernel what kind of socket this is: <B><TT>SOCK_STREAM</TT></B> or=20
<B><TT>SOCK_DGRAM</TT></B>. Finally, just set <I><TT>protocol</TT></I> =
to=20
"<B><TT>0</TT></B>" to have <TT>socket()</TT> choose the correct =
protocol based=20
on the <I><TT>type</TT></I>. (Notes: there are many more =
<I><TT>domain</TT></I>s=20
than I've listed. There are many more <I><TT>type</TT></I>s than I've =
listed.=20
See the <TT>socket()</TT> man page. Also, there's a "better" way to get =
the=20
<I><TT>protocol</TT></I>, but specifying <B><TT>0</TT></B> works in =
99.9% of all=20
cases. See the <TT>getprotobyname()</TT> man page if you're =
curious.)</P>
<P><TT>socket()</TT> simply returns to you a socket descriptor that you =
can use=20
in later system calls, or <B><TT>-1</TT></B> on error. The global =
variable=20
<I><TT>errno</TT></I> is set to the error's value (see the =
<TT>perror()</TT> man=20
page.)</P>
<P>(This <B><TT>PF_INET</TT></B> thing is a close relative of the=20
<B><TT>AF_INET</TT></B> that you used when initializing the=20
<B><TT>sin_family</TT></B> field in your <TT>struct sockaddr_in</TT>. In =
fact,=20
they're so closely related that they actually have the same value, and =
many=20
programmers will call <TT>socket()</TT> and pass <B><TT>AF_INET</TT></B> =
as the=20
first argument instead of <TT>PF_INET</TT>. Now, get some milk and =
cookies,=20
because it's times for a story. Once upon a time, a long time ago, it =
was=20
thought that maybe a address family (what the "AF" in =
"<B><TT>AF_INET</TT></B>"=20
stands for) might support several protocols that were referred to by =
their=20
protocol family (what the "PF" in "<B><TT>PF_INET</TT></B>" stands for). =
That=20
didn't happen. And they all lived happily ever after, The End. So the =
most=20
correct thing to do is to use <B><TT>AF_INET</TT></B> in your <TT>struct =

sockaddr_in</TT> and <B><TT>PF_INET</TT></B> in your call to=20
<TT>socket()</TT>.)</P>
<P>Fine, fine, fine, but what good is this socket? The answer is that =
it's=20
really no good by itself, and you need to read on and make more system =
calls for=20
it to make any sense.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  bind  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.2. <A name=3Dbind><TT>bind()</TT>--What port am I on?</A></H3>
<P></P>
<P>Once you have a socket, you might have to associate that socket with =
a port=20
on your local machine. (This is commonly done if you're going to=20
<TT>listen()</TT> for incoming connections on a specific port--MUDs do =
this when=20
they tell you to "telnet to x.y.z port 6969".) The port number is used =
by the=20
kernel to match an incoming packet to a certain process's socket =
descriptor. If=20
you're going to only be doing a <TT>connect()</TT>, this may be =
unnecessary.=20
Read it anyway, just for kicks.</P>
<P>Here is the synopsis for the <TT>bind()</TT> system call:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int sockfd, struct sockaddr *my_addr, int addrlen);=20
</PRE></TR></TBODY></TABLE></P>
<P><I><TT>sockfd</TT></I> is the socket file descriptor returned by=20
<TT>socket()</TT>. <I><TT>my_addr</TT></I> is a pointer to a <TT>struct=20
sockaddr</TT> that contains information about your address, namely, port =
and IP=20
address. <I><TT>addrlen</TT></I> can be set to <TT>sizeof(struct=20
sockaddr)</TT>.</P>
<P>Whew. That's a bit to absorb in one chunk. Let's have an example:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define MYPORT 3490

main()
{
    int sockfd;
    struct sockaddr_in my_addr;

    sockfd =3D socket(PF_INET, SOCK_STREAM, 0); // do some error =
checking!

    my_addr.sin_family =3D AF_INET;         // host byte order
    my_addr.sin_port =3D htons(MYPORT);     // short, network byte order
    my_addr.sin_addr.s_addr =3D inet_addr("10.12.110.57");
    memset(&amp;(my_addr.sin_zero), '\0', 8); // zero the rest of the =
struct

    // don't forget your error checking for bind():
    bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct =
sockaddr));
    .
    .
    .=20
</PRE></TR></TBODY></TABLE></P>
<P>There are a few things to notice here: =
<I><TT>my_addr.sin_port</TT></I> is in=20
Network Byte Order. So is <I><TT>my_addr.sin_addr.s_addr</TT></I>. =
Another thing=20
to watch out for is that the header files might differ from system to =
system. To=20
be sure, you should check your local <B><TT>man</TT></B> pages.</P>
<P>Lastly, on the topic of <TT>bind()</TT>, I should mention that some =
of the=20
process of getting your own IP address and/or port can be automated:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>my_addr.sin_port =3D 0; // choose an =
unused port at random
my_addr.sin_addr.s_addr =3D INADDR_ANY;  // use my IP address=20
</PRE></TR></TBODY></TABLE></P>
<P>See, by setting <I><TT>my_addr.sin_port</TT></I> to zero, you are =
telling=20
<TT>bind()</TT> to choose the port for you. Likewise, by setting=20
<I><TT>my_addr.sin_addr.s_addr</TT></I> to <B><TT>INADDR_ANY</TT></B>, =
you are=20
telling it to automatically fill in the IP address of the machine the =
process is=20
running on.</P>
<P>If you are into noticing little things, you might have seen that I =
didn't put=20
<B><TT>INADDR_ANY</TT></B> into Network Byte Order! Naughty me. However, =
I have=20
inside info: <B><TT>INADDR_ANY</TT></B> is really zero! Zero still has =
zero on=20
bits even if you rearrange the bytes. However, purists will point out =
that there=20
could be a parallel dimension where <B><TT>INADDR_ANY</TT></B> is, say, =
12 and=20
that my code won't work there. That's ok with me:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>my_addr.sin_port =3D htons(0); // choose =
an unused port at random
my_addr.sin_addr.s_addr =3D htonl(INADDR_ANY);  // use my IP address=20
</PRE></TR></TBODY></TABLE></P>
<P>Now we're so portable you probably wouldn't believe it. I just wanted =
to=20
point that out, since most of the code you come across won't bother =
running=20
<B><TT>INADDR_ANY</TT></B> through <TT>htonl()</TT>.</P>
<P><TT>bind()</TT> also returns <B><TT>-1</TT></B> on error and sets=20
<I><TT>errno</TT></I> to the error's value.</P>
<P>Another thing to watch out for when calling <TT>bind()</TT>: don't go =

underboard with your port numbers. All ports below 1024 are RESERVED =
(unless=20
you're the superuser)! You can have any port number above that, right up =
to=20
65535 (provided they aren't already being used by another program.)</P>
<P>Sometimes, you might notice, you try to rerun a server and =
<TT>bind()</TT>=20
fails, claiming "Address already in use." What does that mean? Well, a =
little=20
bit of a socket that was connected is still hanging around in the =
kernel, and=20
it's hogging the port. You can either wait for it to clear (a minute or =
so), or=20
add code to your program allowing it to reuse the port, like this:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>int yes=3D1;
//char yes=3D'1'; // Solaris people use this

// lose the pesky "Address already in use" error message
if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof(int)) =
=3D=3D -1) {
    perror("setsockopt");
    exit(1);
}=20
</PRE></TR></TBODY></TABLE></P>
<P>One small extra final note about <TT>bind()</TT>: there are times =
when you=20
won't absolutely have to call it. If you are <TT>connect()</TT>ing to a =
remote=20
machine and you don't care what your local port is (as is the case with=20
<B><TT>telnet</TT></B> where you only care about the remote port), you =
can=20
simply call <TT>connect()</TT>, it'll check to see if the socket is =
unbound, and=20
will <TT>bind()</TT> it to an unused local port if necessary.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  connect  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.3. <A name=3Dconnect><TT>connect()</TT>--Hey, you!</A></H3>
<P></P>
<P>Let's just pretend for a few minutes that you're a telnet =
application. Your=20
user commands you (just like in the movie <I>TRON</I>) to get a socket =
file=20
descriptor. You comply and call <TT>socket()</TT>. Next, the user tells =
you to=20
connect to "<TT>10.12.110.57</TT>" on port "<TT>23</TT>" (the standard =
telnet=20
port.) Yow! What do you do now?</P>
<P>Lucky for you, program, you're now perusing the section on=20
<TT>connect()</TT>--how to connect to a remote host. So read furiously =
onward!=20
No time to lose!</P>
<P>The <TT>connect()</TT> call is as follows:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);=20
</PRE></TR></TBODY></TABLE></P>
<P><I><TT>sockfd</TT></I> is our friendly neighborhood socket file =
descriptor,=20
as returned by the <TT>socket()</TT> call, <I><TT>serv_addr</TT></I> is =
a=20
<TT>struct sockaddr</TT> containing the destination port and IP address, =
and=20
<I><TT>addrlen</TT></I> can be set to <TT>sizeof(struct =
sockaddr)</TT>.</P>
<P>Isn't this starting to make more sense? Let's have an example:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define DEST_IP   "10.12.110.57"
#define DEST_PORT 23

main()
{
    int sockfd;
    struct sockaddr_in dest_addr;   // will hold the destination addr

    sockfd =3D socket(PF_INET, SOCK_STREAM, 0); // do some error =
checking!

    dest_addr.sin_family =3D AF_INET;          // host byte order
    dest_addr.sin_port =3D htons(DEST_PORT);   // short, network byte =
order
    dest_addr.sin_addr.s_addr =3D inet_addr(DEST_IP);
    memset(&amp;(dest_addr.sin_zero), '\0', 8);  // zero the rest of the =
struct

    // don't forget to error check the connect()!
    connect(sockfd, (struct sockaddr *)&amp;dest_addr, sizeof(struct =
sockaddr));
    .
    .
    .=20
</PRE></TR></TBODY></TABLE></P>
<P>Again, be sure to check the return value from =
<TT>connect()</TT>--it'll=20
return <B><TT>-1</TT></B> on error and set the variable=20
<I><TT>errno</TT></I>.</P>
<P>Also, notice that we didn't call <TT>bind()</TT>. Basically, we don't =
care=20
about our local port number; we only care where we're going (the remote =
port).=20
The kernel will choose a local port for us, and the site we connect to =
will=20
automatically get this information from us. No worries.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  listen  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.4. <A name=3Dlisten><TT>listen()</TT>--Will somebody please call=20
me?</A></H3>
<P></P>
<P>Ok, time for a change of pace. What if you don't want to connect to a =
remote=20
host. Say, just for kicks, that you want to wait for incoming =
connections and=20
handle them in some way. The process is two step: first you =
<TT>listen()</TT>,=20
then you <TT>accept()</TT> (see below.)</P>
<P>The listen call is fairly simple, but requires a bit of =
explanation:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>int listen(int sockfd, int backlog);=20
</PRE></TR></TBODY></TABLE></P>
<P><I><TT>sockfd</TT></I> is the usual socket file descriptor from the=20
<TT>socket()</TT> system call. <I><TT>backlog</TT></I> is the number of=20
connections allowed on the incoming queue. What does that mean? Well, =
incoming=20
connections are going to wait in this queue until you <TT>accept()</TT> =
them=20
(see below) and this is the limit on how many can queue up. Most systems =

silently limit this number to about 20; you can probably get away with =
setting=20
it to <B><TT>5</TT></B> or <B><TT>10</TT></B>.</P>
<P>Again, as per usual, <TT>listen()</TT> returns <B><TT>-1</TT></B> and =
sets=20
<I><TT>errno</TT></I> on error.</P>
<P>Well, as you can probably imagine, we need to call <TT>bind()</TT> =
before we=20
call <TT>listen()</TT> or the kernel will have us listening on a random =
port.=20
Bleah! So if you're going to be listening for incoming connections, the =
sequence=20
of system calls you'll make is:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>socket();
bind();
listen();
/* accept() goes here */=20
</PRE></TR></TBODY></TABLE></P>
<P>I'll just leave that in the place of sample code, since it's fairly=20
self-explanatory. (The code in the <TT>accept()</TT> section, below, is =
more=20
complete.) The really tricky part of this whole sha-bang is the call to=20
<TT>accept()</TT>.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  accept  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.5. <A name=3Daccept><TT>accept()</TT>--"Thank you for calling port =

3490."</A></H3>
<P></P>
<P>Get ready--the <TT>accept()</TT> call is kinda weird! What's going to =
happen=20
is this: someone far far away will try to <TT>connect()</TT> to your =
machine on=20
a port that you are <TT>listen()</TT>ing on. Their connection will be =
queued up=20
waiting to be <TT>accept()</TT>ed. You call <TT>accept()</TT> and you =
tell it to=20
get the pending connection. It'll return to you a <I>brand new socket =
file=20
descriptor</I> to use for this single connection! That's right, suddenly =
you=20
have <I>two socket file descriptors</I> for the price of one! The =
original one=20
is still listening on your port and the newly created one is finally =
ready to=20
<TT>send()</TT> and <TT>recv()</TT>. We're there! </P>
<P>The call is as follows:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);=20
</PRE></TR></TBODY></TABLE></P>
<P><I><TT>sockfd</TT></I> is the <TT>listen()</TT>ing socket descriptor. =
Easy=20
enough. <I><TT>addr</TT></I> will usually be a pointer to a local =
<TT>struct=20
sockaddr_in</TT>. This is where the information about the incoming =
connection=20
will go (and with it you can determine which host is calling you from =
which=20
port). <I><TT>addrlen</TT></I> is a local integer variable that should =
be set to=20
<TT>sizeof(struct sockaddr_in)</TT> before its address is passed to=20
<TT>accept()</TT>. Accept will not put more than that many bytes into=20
<I><TT>addr</TT></I>. If it puts fewer in, it'll change the value of=20
<I><TT>addrlen</TT></I> to reflect that.</P>
<P>Guess what? <TT>accept()</TT> returns <B><TT>-1</TT></B> and sets=20
<I><TT>errno</TT></I> if an error occurs. Betcha didn't figure that.</P>
<P>Like before, this is a bunch to absorb in one chunk, so here's a =
sample code=20
fragment for your perusal:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define MYPORT 3490    // the port users will be connecting to

#define BACKLOG 10     // how many pending connections queue will hold

main()
{
    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
    struct sockaddr_in my_addr;    // my address information
    struct sockaddr_in their_addr; // connector's address information
    int sin_size;

    sockfd =3D socket(PF_INET, SOCK_STREAM, 0); // do some error =
checking!

    my_addr.sin_family =3D AF_INET;         // host byte order
    my_addr.sin_port =3D htons(MYPORT);     // short, network byte order
    my_addr.sin_addr.s_addr =3D INADDR_ANY; // auto-fill with my IP
    memset(&amp;(my_addr.sin_zero), '\0', 8); // zero the rest of the =
struct

    // don't forget your error checking for these calls:
    bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct =
sockaddr));

    listen(sockfd, BACKLOG);

    sin_size =3D sizeof(struct sockaddr_in);
    new_fd =3D accept(sockfd, (struct sockaddr *)&amp;their_addr, =
&amp;sin_size);
    .
    .
    .=20
</PRE></TR></TBODY></TABLE></P>
<P>Again, note that we will use the socket descriptor =
<I><TT>new_fd</TT></I> for=20
all <TT>send()</TT> and <TT>recv()</TT> calls. If you're only getting =
one single=20
connection ever, you can <TT>close()</TT> the listening =
<I><TT>sockfd</TT></I>=20
in order to prevent more incoming connections on the same port, if you =
so=20
desire.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  sendrecv  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.6. <A name=3Dsendrecv><TT>send()</TT> and <TT>recv()</TT>--Talk to =
me,=20
baby!</A></H3>
<P></P>
<P>These two functions are for communicating over stream sockets or =
connected=20
datagram sockets. If you want to use regular unconnected datagram =
sockets,=20
you'll need to see the section on <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendtorec=
v"><TT>sendto()</TT>=20
and <TT>recvfrom()</TT></A>, below.</P>
<P>The <TT>send()</TT> call:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>int send(int sockfd, const void *msg, int =
len, int flags);=20
</PRE></TR></TBODY></TABLE></P>
<P><I><TT>sockfd</TT></I> is the socket descriptor you want to send data =
to=20
(whether it's the one returned by <TT>socket()</TT> or the one you got =
with=20
<TT>accept()</TT>.) <I><TT>msg</TT></I> is a pointer to the data you =
want to=20
send, and <I><TT>len</TT></I> is the length of that data in bytes. Just =
set=20
<I><TT>flags</TT></I> to <B><TT>0</TT></B>. (See the <TT>send()</TT> man =
page=20
for more information concerning flags.)</P>
<P>Some sample code might be:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>char *msg =3D "Beej was here!";
int len, bytes_sent;
.
.
.
len =3D strlen(msg);
bytes_sent =3D send(sockfd, msg, len, 0);
.
.
.=20
</PRE></TR></TBODY></TABLE></P>
<P><TT>send()</TT> returns the number of bytes actually sent =
out--<I>this might=20
be less than the number you told it to send!</I> See, sometimes you tell =
it to=20
send a whole gob of data and it just can't handle it. It'll fire off as =
much of=20
the data as it can, and trust you to send the rest later. Remember, if =
the value=20
returned by <TT>send()</TT> doesn't match the value in =
<I><TT>len</TT></I>, it's=20
up to you to send the rest of the string. The good news is this: if the =
packet=20
is small (less than 1K or so) it will <I>probably</I> manage to send the =
whole=20
thing all in one go. Again, <B><TT>-1</TT></B> is returned on error, and =

<I><TT>errno</TT></I> is set to the error number.</P>
<P>The <TT>recv()</TT> call is similar in many respects:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>int recv(int sockfd, void *buf, int len, =
unsigned int flags);=20
</PRE></TR></TBODY></TABLE></P>
<P><I><TT>sockfd</TT></I> is the socket descriptor to read from,=20
<I><TT>buf</TT></I> is the buffer to read the information into,=20
<I><TT>len</TT></I> is the maximum length of the buffer, and=20
<I><TT>flags</TT></I> can again be set to <B><TT>0</TT></B>. (See the=20
<TT>recv()</TT> man page for flag information.)</P>
<P><TT>recv()</TT> returns the number of bytes actually read into the =
buffer, or=20
<B><TT>-1</TT></B> on error (with <I><TT>errno</TT></I> set, =
accordingly.)</P>
<P>Wait! <TT>recv()</TT> can return <B><TT>0</TT></B>. This can mean =
only one=20
thing: the remote side has closed the connection on you! A return value =
of=20
<B><TT>0</TT></B> is <TT>recv()</TT>'s way of letting you know this has=20
occurred.</P>
<P>There, that was easy, wasn't it? You can now pass data back and forth =
on=20
stream sockets! Whee! You're a Unix Network Programmer!</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  sendtorecv  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.7. <A name=3Dsendtorecv><TT>sendto()</TT> and =
<TT>recvfrom()</TT>--Talk to=20
me, DGRAM-style</A></H3>
<P></P>
<P>"This is all fine and dandy," I hear you saying, "but where does this =
leave=20
me with unconnected datagram sockets?" No problemo, amigo. We have just =
the=20
thing.</P>
<P>Since datagram sockets aren't connected to a remote host, guess which =
piece=20
of information we need to give before we send a packet? That's right! =
The=20
destination address! Here's the scoop:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>int sendto(int sockfd, const void *msg, =
int len, unsigned int flags,
           const struct sockaddr *to, socklen_t tolen);=20
</PRE></TR></TBODY></TABLE></P>
<P>As you can see, this call is basically the same as the call to=20
<TT>send()</TT> with the addition of two other pieces of information.=20
<I><TT>to</TT></I> is a pointer to a <TT>struct sockaddr</TT> (which =
you'll=20
probably have as a <TT>struct sockaddr_in</TT> and cast it at the last =
minute)=20
which contains the destination IP address and port. =
<I><TT>tolen</TT></I>, an=20
<TT>int</TT> deep-down, can simply be set to <TT>sizeof(struct=20
sockaddr)</TT>.</P>
<P>Just like with <TT>send()</TT>, <TT>sendto()</TT> returns the number =
of bytes=20
actually sent (which, again, might be less than the number of bytes you =
told it=20
to send!), or <B><TT>-1</TT></B> on error.</P>
<P>Equally similar are <TT>recv()</TT> and <TT>recvfrom()</TT>. The =
synopsis of=20
<TT>recvfrom()</TT> is:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>int recvfrom(int sockfd, void *buf, int =
len, unsigned int flags,
             struct sockaddr *from, int *fromlen);=20
</PRE></TR></TBODY></TABLE></P>
<P>Again, this is just like <TT>recv()</TT> with the addition of a =
couple=20
fields. <I><TT>from</TT></I> is a pointer to a local <TT>struct =
sockaddr</TT>=20
that will be filled with the IP address and port of the originating =
machine.=20
<I><TT>fromlen</TT></I> is a pointer to a local <TT>int</TT> that should =
be=20
initialized to <TT>sizeof(struct sockaddr)</TT>. When the function =
returns,=20
<I><TT>fromlen</TT></I> will contain the length of the address actually =
stored=20
in <I><TT>from</TT></I>.</P>
<P><TT>recvfrom()</TT> returns the number of bytes received, or=20
<B><TT>-1</TT></B> on error (with <I><TT>errno</TT></I> set =
accordingly.)</P>
<P>Remember, if you <TT>connect()</TT> a datagram socket, you can then =
simply=20
use <TT>send()</TT> and <TT>recv()</TT> for all your transactions. The =
socket=20
itself is still a datagram socket and the packets still use UDP, but the =
socket=20
interface will automatically add the destination and source information =
for=20
you.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  closedown  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.8. <A name=3Dclosedown><TT>close()</TT> and =
<TT>shutdown()</TT>--Get outta=20
my face!</A></H3>
<P></P>
<P>Whew! You've been <TT>send()</TT>ing and <TT>recv()</TT>ing data all =
day=20
long, and you've had it. You're ready to close the connection on your =
socket=20
descriptor. This is easy. You can just use the regular Unix file =
descriptor=20
<TT>close()</TT> function:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>close(sockfd);=20
</PRE></TR></TBODY></TABLE></P>
<P>This will prevent any more reads and writes to the socket. Anyone =
attempting=20
to read or write the socket on the remote end will receive an error.</P>
<P>Just in case you want a little more control over how the socket =
closes, you=20
can use the <TT>shutdown()</TT> function. It allows you to cut off =
communication=20
in a certain direction, or both ways (just like <TT>close()</TT> does.)=20
Synopsis:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>int shutdown(int sockfd, int how);=20
</PRE></TR></TBODY></TABLE></P>
<P><I><TT>sockfd</TT></I> is the socket file descriptor you want to =
shutdown,=20
and <I><TT>how</TT></I> is one of the following:</P>
<UL>
  <LI><B><TT>0</TT></B> -- Further receives are disallowed=20
  <LI><B><TT>1</TT></B> -- Further sends are disallowed=20
  <LI><B><TT>2</TT></B> -- Further sends and receives are disallowed =
(like=20
  <TT>close()</TT>) </LI></UL>
<P><TT>shutdown()</TT> returns <B><TT>0</TT></B> on success, and=20
<B><TT>-1</TT></B> on error (with <I><TT>errno</TT></I> set =
accordingly.)</P>
<P>If you deign to use <TT>shutdown()</TT> on unconnected datagram =
sockets, it=20
will simply make the socket unavailable for further <TT>send()</TT> and=20
<TT>recv()</TT> calls (remember that you can use these if you =
<TT>connect()</TT>=20
your datagram socket.)</P>
<P>It's important to note that <TT>shutdown()</TT> doesn't actually =
close the=20
file descriptor--it just changes its usability. To free a socket =
descriptor, you=20
need to use <TT>close()</TT>.</P>
<P>Nothing to it.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  getpeername  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.9. <A name=3Dgetpeername><TT>getpeername()</TT>--Who are =
you?</A></H3>
<P></P>
<P>This function is so easy.</P>
<P>It's so easy, I almost didn't give it it's own section. But here it =
is=20
anyway.</P>
<P>The function <TT>getpeername()</TT> will tell you who is at the other =
end of=20
a connected stream socket. The synopsis:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;sys/socket.h&gt;

int getpeername(int sockfd, struct sockaddr *addr, int *addrlen);=20
</PRE></TR></TBODY></TABLE></P>
<P><I><TT>sockfd</TT></I> is the descriptor of the connected stream =
socket,=20
<I><TT>addr</TT></I> is a pointer to a <TT>struct sockaddr</TT> (or a =
<TT>struct=20
sockaddr_in</TT>) that will hold the information about the other side of =
the=20
connection, and <I><TT>addrlen</TT></I> is a pointer to an <TT>int</TT>, =
that=20
should be initialized to <TT>sizeof(struct sockaddr)</TT>.</P>
<P>The function returns <B><TT>-1</TT></B> on error and sets=20
<I><TT>errno</TT></I> accordingly.</P>
<P>Once you have their address, you can use <TT>inet_ntoa()</TT> or=20
<TT>gethostbyaddr()</TT> to print or get more information. No, you can't =
get=20
their login name. (Ok, ok. If the other computer is running an ident =
daemon,=20
this is possible. This, however, is beyond the scope of this document. =
Check out=20
<A href=3D"http://www.rfc-editor.org/rfc/rfc1413.txt">RFC-1413</A> for =
more=20
info.)</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  gethostname  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.10. <A name=3Dgethostname><TT>gethostname()</TT>--Who am =
I?</A></H3>
<P></P>
<P>Even easier than <TT>getpeername()</TT> is the function=20
<TT>gethostname()</TT>. It returns the name of the computer that your =
program is=20
running on. The name can then be used by <TT>gethostbyname()</TT>, =
below, to=20
determine the IP address of your local machine.</P>
<P>What could be more fun? I could think of a few things, but they don't =
pertain=20
to socket programming. Anyway, here's the breakdown:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;unistd.h&gt;

int gethostname(char *hostname, size_t size);=20
</PRE></TR></TBODY></TABLE></P>
<P>The arguments are simple: <I><TT>hostname</TT></I> is a pointer to an =
array=20
of chars that will contain the hostname upon the function's return, and=20
<I><TT>size</TT></I> is the length in bytes of the =
<I><TT>hostname</TT></I>=20
array.</P>
<P>The function returns <B><TT>0</TT></B> on successful completion, and=20
<B><TT>-1</TT></B> on error, setting <I><TT>errno</TT></I> as =
usual.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  dns  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>4.11. <A name=3Ddns>DNS--You say "whitehouse.gov", I say=20
"63.161.169.137"</A></H3>
<P></P>
<P>In case you don't know what DNS is, it stands for "Domain Name =
Service". In a=20
nutshell, you tell it what the human-readable address is for a site, and =
it'll=20
give you the IP address (so you can use it with <TT>bind()</TT>,=20
<TT>connect()</TT>, <TT>sendto()</TT>, or whatever you need it for.) =
This way,=20
when someone enters:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>$ telnet whitehouse.gov
</PRE></TR></TBODY></TABLE></P>
<P><B><TT>telnet</TT></B> can find out that it needs to =
<TT>connect()</TT> to=20
"63.161.169.137".</P>
<P>But how does it work? You'll be using the function=20
<TT>gethostbyname()</TT>:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;netdb.h&gt;

struct hostent *gethostbyname(const char *name);=20
</PRE></TR></TBODY></TABLE></P>
<P>As you see, it returns a pointer to a <TT>struct hostent</TT>, the =
layout of=20
which is as follows:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>struct hostent {
    char    *h_name;
    char    **h_aliases;
    int     h_addrtype;
    int     h_length;
    char    **h_addr_list;
};
#define h_addr h_addr_list[0]=20
</PRE></TR></TBODY></TABLE></P>
<P>And here are the descriptions of the fields in the <TT>struct=20
hostent</TT>:</P>
<UL>
  <LI><I><TT>h_name</TT></I> -- Official name of the host.=20
  <LI><I><TT>h_aliases</TT></I> -- A NULL-terminated array of alternate =
names=20
  for the host.=20
  <LI><I><TT>h_addrtype</TT></I> -- The type of address being returned; =
usually=20
  <I><TT>AF_INET</TT></I>.=20
  <LI><I><TT>h_length</TT></I> -- The length of the address in bytes.=20
  <LI><I><TT>h_addr_list</TT></I> -- A zero-terminated array of network=20
  addresses for the host. Host addresses are in Network Byte Order.=20
  <LI><I><TT>h_addr</TT></I> -- The first address in=20
  <I><TT>h_addr_list</TT></I>. </LI></UL>
<P><TT>gethostbyname()</TT> returns a pointer to the filled <TT>struct=20
hostent</TT>, or NULL on error. (But <I><TT>errno</TT></I> is <I>not</I> =

set--<I><I><TT>h_errno</TT></I></I> is set instead. See =
<TT>herror()</TT>,=20
below.)</P>
<P>But how is it used? Sometimes (as we find from reading computer =
manuals),=20
just spewing the information at the reader is not enough. This function =
is=20
certainly easier to use than it looks.</P>
<P><A href=3D"http://beej.us/guide/bgnet/examples/getip.c">Here's an =
example=20
program</A>:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>/*
** getip.c -- a hostname lookup demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

int main(int argc, char *argv[])
{
    struct hostent *h;

    if (argc !=3D 2) {  // error check the command line
        fprintf(stderr,"usage: getip address\n");
        exit(1);
    }

    if ((h=3Dgethostbyname(argv[1])) =3D=3D NULL) {  // get the host =
info
        herror("gethostbyname");
        exit(1);
    }

    printf("Host name  : %s\n", h-&gt;h_name);
    printf("IP Address : %s\n", inet_ntoa(*((struct in_addr =
*)h-&gt;h_addr)));
  =20
   return 0;
}=20
</PRE></TR></TBODY></TABLE></P>
<P>With <TT>gethostbyname()</TT>, you can't use <TT>perror()</TT> to =
print error=20
message (since <I><TT>errno</TT></I> is not used). Instead, call=20
<TT>herror()</TT>.</P>
<P>It's pretty straightforward. You simply pass the string that contains =
the=20
machine name ("whitehouse.gov") to <TT>gethostbyname()</TT>, and then =
grab the=20
information out of the returned <TT>struct hostent</TT>.</P>
<P>The only possible weirdness might be in the printing of the IP =
address,=20
above. <I><TT>h-&gt;h_addr</TT></I> is a <TT>char*</TT>, but=20
<TT>inet_ntoa()</TT> wants a <TT>struct in_addr</TT> passed to it. So I =
cast=20
<I><TT>h-&gt;h_addr</TT></I> to a <TT>struct in_addr*</TT>, then =
dereference it=20
to get at the data.</P><!--  syscalls  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  clientserver  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<HR>

<H2>5. <A name=3Dclientserver>Client-Server Background</A></H2>
<P></P>
<P>It's a client-server world, baby. Just about everything on the =
network deals=20
with client processes talking to server processes and vice-versa. Take=20
<B><TT>telnet</TT></B>, for instance. When you connect to a remote host =
on port=20
23 with telnet (the client), a program on that host (called=20
<B><TT>telnetd</TT></B>, the server) springs to life. It handles the =
incoming=20
telnet connection, sets you up with a login prompt, etc.</P>
<HR>

<CENTER><IMG alt=3DNone =
src=3D"http://beej.us/guide/bgnet/output/htmlsingle/cs.png">=20

<P><B>Client-Server Interaction.</B></P></CENTER>
<HR>

<P>The exchange of information between client and server is summarized =
in <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#figure2">=
Figure=20
2</A>.</P>
<P>Note that the client-server pair can speak =
<B><TT>SOCK_STREAM</TT></B>,=20
<B><TT>SOCK_DGRAM</TT></B>, or anything else (as long as they're =
speaking the=20
same thing.) Some good examples of client-server pairs are=20
<B><TT>telnet</TT></B>/<B><TT>telnetd</TT></B>,=20
<B><TT>ftp</TT></B>/<B><TT>ftpd</TT></B>, or=20
<B><TT>bootp</TT></B>/<B><TT>bootpd</TT></B>. Every time you use=20
<B><TT>ftp</TT></B>, there's a remote program, <B><TT>ftpd</TT></B>, =
that serves=20
you.</P>
<P>Often, there will only be one server on a machine, and that server =
will=20
handle multiple clients using <TT>fork()</TT>. The basic routine is: =
server will=20
wait for a connection, <TT>accept()</TT> it, and <TT>fork()</TT> a child =
process=20
to handle it. This is what our sample server does in the next =
section.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  simpleserver  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>5.1. <A name=3Dsimpleserver>A Simple Stream Server</A></H3>
<P></P>
<P>All this server does is send the string "<TT>Hello, World!\n</TT>" =
out over a=20
stream connection. All you need to do to test this server is run it in =
one=20
window, and telnet to it from another with:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>$ telnet remotehostname 3490
</PRE></TR></TBODY></TABLE></P>
<P>where <TT>remotehostname</TT> is the name of the machine you're =
running it=20
on.</P>
<P><A href=3D"http://beej.us/guide/bgnet/examples/server.c">The server =
code</A>:=20
(Note: a trailing backslash on a line means that the line is continued =
on the=20
next.)</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>/*
** server.c -- a stream socket server demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;

#define MYPORT 3490    // the port users will be connecting to

#define BACKLOG 10     // how many pending connections queue will hold

void sigchld_handler(int s)
{
    while(waitpid(-1, NULL, WNOHANG) &gt; 0);
}

int main(void)
{
    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
    struct sockaddr_in my_addr;    // my address information
    struct sockaddr_in their_addr; // connector's address information
    socklen_t sin_size;
    struct sigaction sa;
    int yes=3D1;

    if ((sockfd =3D socket(PF_INET, SOCK_STREAM, 0)) =3D=3D -1) {
        perror("socket");
        exit(1);
    }

    if (setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof(int)) =
=3D=3D -1) {
        perror("setsockopt");
        exit(1);
    }
   =20
    my_addr.sin_family =3D AF_INET;         // host byte order
    my_addr.sin_port =3D htons(MYPORT);     // short, network byte order
    my_addr.sin_addr.s_addr =3D INADDR_ANY; // automatically fill with =
my IP
    memset(&amp;(my_addr.sin_zero), '\0', 8); // zero the rest of the =
struct

    if (bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct =
sockaddr))
                                                                   =
=3D=3D -1) {
        perror("bind");
        exit(1);
    }

    if (listen(sockfd, BACKLOG) =3D=3D -1) {
        perror("listen");
        exit(1);
    }

    sa.sa_handler =3D sigchld_handler; // reap all dead processes
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags =3D SA_RESTART;
    if (sigaction(SIGCHLD, &amp;sa, NULL) =3D=3D -1) {
        perror("sigaction");
        exit(1);
    }

    while(1) {  // main accept() loop
        sin_size =3D sizeof(struct sockaddr_in);
        if ((new_fd =3D accept(sockfd, (struct sockaddr =
*)&amp;their_addr,
                                                       &amp;sin_size)) =
=3D=3D -1) {
            perror("accept");
            continue;
        }
        printf("server: got connection from %s\n",
                                           =
inet_ntoa(their_addr.sin_addr));
        if (!fork()) { // this is the child process
            close(sockfd); // child doesn't need the listener
            if (send(new_fd, "Hello, world!\n", 14, 0) =3D=3D -1)
                perror("send");
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // parent doesn't need this
    }

    return 0;
}=20
</PRE></TR></TBODY></TABLE></P>
<P>In case you're curious, I have the code in one big <TT>main()</TT> =
function=20
for (I feel) syntactic clarity. Feel free to split it into smaller =
functions if=20
it makes you feel better.</P>
<P>(Also, this whole <TT>sigaction()</TT> thing might be new to =
you--that's ok.=20
The code that's there is responsible for reaping zombie processes that =
appear as=20
the <TT>fork()</TT>ed child processes exit. If you make lots of zombies =
and=20
don't reap them, your system administrator will become agitated.)</P>
<P>You can get the data from this server by using the client listed in =
the next=20
section.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  simpleclient  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>5.2. <A name=3Dsimpleclient>A Simple Stream Client</A></H3>
<P></P>
<P>This guy's even easier than the server. All this client does is =
connect to=20
the host you specify on the command line, port 3490. It gets the string =
that the=20
server sends.</P>
<P><A href=3D"http://beej.us/guide/bgnet/examples/client.c">The client=20
source</A>:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>/*
** client.c -- a stream socket client demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#define PORT 3490 // the port client will be connecting to=20

#define MAXDATASIZE 100 // max number of bytes we can get at once=20

int main(int argc, char *argv[])
{
    int sockfd, numbytes; =20
    char buf[MAXDATASIZE];
    struct hostent *he;
    struct sockaddr_in their_addr; // connector's address information=20

    if (argc !=3D 2) {
        fprintf(stderr,"usage: client hostname\n");
        exit(1);
    }

    if ((he=3Dgethostbyname(argv[1])) =3D=3D NULL) {  // get the host =
info=20
        herror("gethostbyname");
        exit(1);
    }

    if ((sockfd =3D socket(PF_INET, SOCK_STREAM, 0)) =3D=3D -1) {
        perror("socket");
        exit(1);
    }

    their_addr.sin_family =3D AF_INET;    // host byte order=20
    their_addr.sin_port =3D htons(PORT);  // short, network byte order=20
    their_addr.sin_addr =3D *((struct in_addr *)he-&gt;h_addr);
    memset(&amp;(their_addr.sin_zero), '\0', 8);  // zero the rest of =
the struct=20

    if (connect(sockfd, (struct sockaddr *)&amp;their_addr,
                                          sizeof(struct sockaddr)) =
=3D=3D -1) {
        perror("connect");
        exit(1);
    }

    if ((numbytes=3Drecv(sockfd, buf, MAXDATASIZE-1, 0)) =3D=3D -1) {
        perror("recv");
        exit(1);
    }

    buf[numbytes] =3D '\0';

    printf("Received: %s",buf);

    close(sockfd);

    return 0;
}=20
</PRE></TR></TBODY></TABLE></P>
<P>Notice that if you don't run the server before you run the client,=20
<TT>connect()</TT> returns "Connection refused". Very useful.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  datagram  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>5.3. <A name=3Ddatagram>Datagram Sockets</A></H3>
<P></P>
<P>I really don't have that much to talk about here, so I'll just =
present a=20
couple of sample programs: <I><TT>talker.c</TT></I> and=20
<I><TT>listener.c</TT></I>.</P>
<P><B><TT>listener</TT></B> sits on a machine waiting for an incoming =
packet on=20
port 4950. <B><TT>talker</TT></B> sends a packet to that port, on the =
specified=20
machine, that contains whatever the user enters on the command line.</P>
<P>Here is the <A =
href=3D"http://beej.us/guide/bgnet/examples/listener.c">source=20
for <I><TT>listener.c</TT></I></A>:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>/*
** listener.c -- a datagram sockets "server" demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define MYPORT 4950    // the port users will be connecting to

#define MAXBUFLEN 100

int main(void)
{
    int sockfd;
    struct sockaddr_in my_addr;    // my address information
    struct sockaddr_in their_addr; // connector's address information
    socklen_t addr_len;
    int numbytes;
    char buf[MAXBUFLEN];

    if ((sockfd =3D socket(PF_INET, SOCK_DGRAM, 0)) =3D=3D -1) {
        perror("socket");
        exit(1);
    }

    my_addr.sin_family =3D AF_INET;         // host byte order
    my_addr.sin_port =3D htons(MYPORT);     // short, network byte order
    my_addr.sin_addr.s_addr =3D INADDR_ANY; // automatically fill with =
my IP
    memset(&amp;(my_addr.sin_zero), '\0', 8); // zero the rest of the =
struct

    if (bind(sockfd, (struct sockaddr *)&amp;my_addr,
        sizeof(struct sockaddr)) =3D=3D -1) {
        perror("bind");
        exit(1);
    }

    addr_len =3D sizeof(struct sockaddr);
    if ((numbytes=3Drecvfrom(sockfd, buf, MAXBUFLEN-1 , 0,
        (struct sockaddr *)&amp;their_addr, &amp;addr_len)) =3D=3D -1) {
        perror("recvfrom");
        exit(1);
    }

    printf("got packet from %s\n",inet_ntoa(their_addr.sin_addr));
    printf("packet is %d bytes long\n",numbytes);
    buf[numbytes] =3D '\0';
    printf("packet contains \"%s\"\n",buf);

    close(sockfd);

    return 0;
}=20
</PRE></TR></TBODY></TABLE></P>
<P>Notice that in our call to <TT>socket()</TT> we're finally using=20
<B><TT>SOCK_DGRAM</TT></B>. Also, note that there's no need to =
<TT>listen()</TT>=20
or <TT>accept()</TT>. This is one of the perks of using unconnected =
datagram=20
sockets!</P>
<P>Next comes the <A =
href=3D"http://beej.us/guide/bgnet/examples/talker.c">source=20
for <I><TT>talker.c</TT></I></A>:</P><!--  BEGIN talker.c  -->
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>/*
** talker.c -- a datagram "client" demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT 4950    // the port users will be connecting to

int main(int argc, char *argv[])
{
    int sockfd;
    struct sockaddr_in their_addr; // connector's address information
    struct hostent *he;
    int numbytes;

    if (argc !=3D 3) {
        fprintf(stderr,"usage: talker hostname message\n");
        exit(1);
    }

    if ((he=3Dgethostbyname(argv[1])) =3D=3D NULL) {  // get the host =
info
        perror("gethostbyname");
        exit(1);
    }

    if ((sockfd =3D socket(AF_INET, SOCK_DGRAM, 0)) =3D=3D -1) {
        perror("socket");
        exit(1);
    }

    their_addr.sin_family =3D AF_INET;     // host byte order
    their_addr.sin_port =3D htons(SERVERPORT); // short, network byte =
order
    their_addr.sin_addr =3D *((struct in_addr *)he-&gt;h_addr);
    memset(&amp;(their_addr.sin_zero), '\0', 8);  // zero the rest of =
the struct

    if ((numbytes =3D sendto(sockfd, argv[2], strlen(argv[2]), 0,
             (struct sockaddr *)&amp;their_addr, sizeof(struct =
sockaddr))) =3D=3D -1) {
        perror("sendto");
        exit(1);
    }

    printf("sent %d bytes to %s\n", numbytes, =
inet_ntoa(their_addr.sin_addr));

    close(sockfd);

    return 0;
}</PRE></TR></TBODY></TABLE></P><!--  END talker.c  -->
<P>And that's all there is to it! Run <B><TT>listener</TT></B> on some =
machine,=20
then run <B><TT>talker</TT></B> on another. Watch them communicate! Fun =
G-rated=20
excitement for the entire nuclear family!</P>
<P>Except for one more tiny detail that I've mentioned many times in the =
past:=20
connected datagram sockets. I need to talk about this here, since we're =
in the=20
datagram section of the document. Let's say that <B><TT>talker</TT></B> =
calls=20
<TT>connect()</TT> and specifies the <B><TT>listener</TT></B>'s address. =
From=20
that point on, <B><TT>talker</TT></B> may only sent to and receive from =
the=20
address specified by <TT>connect()</TT>. For this reason, you don't have =
to use=20
<TT>sendto()</TT> and <TT>recvfrom()</TT>; you can simply use =
<TT>send()</TT>=20
and <TT>recv()</TT>.</P><!--  clientserver  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  advanced  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<HR>

<H2>6. <A name=3Dadvanced>Slightly Advanced Techniques</A></H2>
<P></P>
<P>These aren't <I>really</I> advanced, but they're getting out of the =
more=20
basic levels we've already covered. In fact, if you've gotten this far, =
you=20
should consider yourself fairly accomplished in the basics of Unix =
network=20
programming! Congratulations!</P>
<P>So here we go into the brave new world of some of the more esoteric =
things=20
you might want to learn about sockets. Have at it!</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  blocking  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>6.1. <A name=3Dblocking>Blocking</A></H3>
<P></P>
<P>Blocking. You've heard about it--now what the heck is it? In a =
nutshell,=20
"block" is techie jargon for "sleep". You probably noticed that when you =
run=20
<B><TT>listener</TT></B>, above, it just sits there until a packet =
arrives. What=20
happened is that it called <TT>recvfrom()</TT>, there was no data, and =
so=20
<TT>recvfrom()</TT> is said to "block" (that is, sleep there) until some =
data=20
arrives.</P>
<P>Lots of functions block. <TT>accept()</TT> blocks. All the =
<TT>recv()</TT>=20
functions block. The reason they can do this is because they're allowed =
to. When=20
you first create the socket descriptor with <TT>socket()</TT>, the =
kernel sets=20
it to blocking. If you don't want a socket to be blocking, you have to =
make a=20
call to <TT>fcntl()</TT>:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
.
.
.
sockfd =3D socket(PF_INET, SOCK_STREAM, 0);
fcntl(sockfd, F_SETFL, O_NONBLOCK);
.
.
.=20
</PRE></TR></TBODY></TABLE></P>
<P>By setting a socket to non-blocking, you can effectively "poll" the =
socket=20
for information. If you try to read from a non-blocking socket and =
there's no=20
data there, it's not allowed to block--it will return <B><TT>-1</TT></B> =
and=20
<I><TT>errno</TT></I> will be set to <B><TT>EWOULDBLOCK</TT></B>.</P>
<P>Generally speaking, however, this type of polling is a bad idea. If =
you put=20
your program in a busy-wait looking for data on the socket, you'll suck =
up CPU=20
time like it was going out of style. A more elegant solution for =
checking to see=20
if there's data waiting to be read comes in the following section on=20
<TT>select()</TT>.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  select  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>6.2. <A name=3Dselect><TT>select()</TT>--Synchronous I/O =
Multiplexing</A></H3>
<P></P>
<P>This function is somewhat strange, but it's very useful. Take the =
following=20
situation: you are a server and you want to listen for incoming =
connections as=20
well as keep reading from the connections you already have.</P>
<P>No problem, you say, just an <TT>accept()</TT> and a couple of=20
<TT>recv()</TT>s. Not so fast, buster! What if you're blocking on an=20
<TT>accept()</TT> call? How are you going to <TT>recv()</TT> data at the =
same=20
time? "Use non-blocking sockets!" No way! You don't want to be a CPU =
hog. What,=20
then?</P>
<P><TT>select()</TT> gives you the power to monitor several sockets at =
the same=20
time. It'll tell you which ones are ready for reading, which are ready =
for=20
writing, and which sockets have raised exceptions, if you really want to =
know=20
that.</P>
<P>Without any further ado, I'll offer the synopsis of =
<TT>select()</TT>:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int select(int numfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);=20
</PRE></TR></TBODY></TABLE></P>
<P>The function monitors "sets" of file descriptors; in particular=20
<I><TT>readfds</TT></I>, <I><TT>writefds</TT></I>, and=20
<I><TT>exceptfds</TT></I>. If you want to see if you can read from =
standard=20
input and some socket descriptor, <I><TT>sockfd</TT></I>, just add the =
file=20
descriptors <B><TT>0</TT></B> and <I><TT>sockfd</TT></I> to the set=20
<I><TT>readfds</TT></I>. The parameter <I><TT>numfds</TT></I> should be =
set to=20
the values of the highest file descriptor plus one. In this example, it =
should=20
be set to <I><TT>sockfd+1</TT></I>, since it is assuredly higher than =
standard=20
input (<B><TT>0</TT></B>).</P>
<P>When <TT>select()</TT> returns, <I><TT>readfds</TT></I> will be =
modified to=20
reflect which of the file descriptors you selected which is ready for =
reading.=20
You can test them with the macro <TT>FD_ISSET()</TT>, below.</P>
<P>Before progressing much further, I'll talk about how to manipulate =
these=20
sets. Each set is of the type <TT>fd_set</TT>. The following macros =
operate on=20
this type:</P>
<UL>
  <LI><TT>FD_ZERO(fd_set *set)</TT> -- clears a file descriptor set=20
  <LI><TT>FD_SET(int fd, fd_set *set)</TT> -- adds <I><TT>fd</TT></I> to =
the set=20

  <LI><TT>FD_CLR(int fd, fd_set *set)</TT> -- removes <I><TT>fd</TT></I> =
from=20
  the set=20
  <LI><TT>FD_ISSET(int fd, fd_set *set)</TT> -- tests to see if=20
  <I><TT>fd</TT></I> is in the set </LI></UL>
<P>Finally, what is this weirded out <TT>struct timeval</TT>? Well, =
sometimes=20
you don't want to wait forever for someone to send you some data. Maybe =
every 96=20
seconds you want to print "Still Going..." to the terminal even though =
nothing=20
has happened. This time structure allows you to specify a timeout =
period. If the=20
time is exceeded and <TT>select()</TT> still hasn't found any ready file =

descriptors, it'll return so you can continue processing.</P>
<P>The <TT>struct timeval</TT> has the follow fields:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>struct timeval {
    int tv_sec;     // seconds
    int tv_usec;    // microseconds
};=20
</PRE></TR></TBODY></TABLE></P>
<P>Just set <I><TT>tv_sec</TT></I> to the number of seconds to wait, and =
set=20
<I><TT>tv_usec</TT></I> to the number of microseconds to wait. Yes, =
that's=20
<I>micro</I>seconds, not milliseconds. There are 1,000 microseconds in a =

millisecond, and 1,000 milliseconds in a second. Thus, there are =
1,000,000=20
microseconds in a second. Why is it "usec"? The "u" is supposed to look =
like the=20
Greek letter &#956; (Mu) that we use for "micro". Also, when the =
function returns,=20
<I><TT>timeout</TT></I> <I>might</I> be updated to show the time still=20
remaining. This depends on what flavor of Unix you're running.</P>
<P>Yay! We have a microsecond resolution timer! Well, don't count on it. =

Standard Unix timeslice is around 100 milliseconds, so you might have to =
wait=20
that long no matter how small you set your <TT>struct timeval</TT>.</P>
<P>Other things of interest: If you set the fields in your <TT>struct=20
timeval</TT> to <B><TT>0</TT></B>, <TT>select()</TT> will timeout =
immediately,=20
effectively polling all the file descriptors in your sets. If you set =
the=20
parameter <I><TT>timeout</TT></I> to NULL, it will never timeout, and =
will wait=20
until the first file descriptor is ready. Finally, if you don't care =
about=20
waiting for a certain set, you can just set it to NULL in the call to=20
<TT>select()</TT>.</P>
<P><A href=3D"http://beej.us/guide/bgnet/examples/select.c">The =
following code=20
snippet</A> waits 2.5 seconds for something to appear on standard =
input:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>/*
** select.c -- a select() demo
*/

#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#define STDIN 0  // file descriptor for standard input

int main(void)
{
    struct timeval tv;
    fd_set readfds;

    tv.tv_sec =3D 2;
    tv.tv_usec =3D 500000;

    FD_ZERO(&amp;readfds);
    FD_SET(STDIN, &amp;readfds);

    // don't care about writefds and exceptfds:
    select(STDIN+1, &amp;readfds, NULL, NULL, &amp;tv);

    if (FD_ISSET(STDIN, &amp;readfds))
        printf("A key was pressed!\n");
    else
        printf("Timed out.\n");

    return 0;
}=20
</PRE></TR></TBODY></TABLE></P>
<P>If you're on a line buffered terminal, the key you hit should be =
RETURN or it=20
will time out anyway.</P>
<P>Now, some of you might think this is a great way to wait for data on =
a=20
datagram socket--and you are right: it <I>might</I> be. Some Unices can =
use=20
select in this manner, and some can't. You should see what your local =
man page=20
says on the matter if you want to attempt it.</P>
<P>Some Unices update the time in your <TT>struct timeval</TT> to =
reflect the=20
amount of time still remaining before a timeout. But others do not. =
Don't rely=20
on that occurring if you want to be portable. (Use =
<TT>gettimeofday()</TT> if=20
you need to track time elapsed. It's a bummer, I know, but that's the =
way it=20
is.)</P>
<P>What happens if a socket in the read set closes the connection? Well, =
in that=20
case, <TT>select()</TT> returns with that socket descriptor set as =
"ready to=20
read". When you actually do <TT>recv()</TT> from it, <TT>recv()</TT> =
will return=20
<B><TT>0</TT></B>. That's how you know the client has closed the =
connection.</P>
<P>One more note of interest about <TT>select()</TT>: if you have a =
socket that=20
is <TT>listen()</TT>ing, you can check to see if there is a new =
connection by=20
putting that socket's file descriptor in the <I><TT>readfds</TT></I> =
set.</P>
<P>And that, my friends, is a quick overview of the almighty =
<TT>select()</TT>=20
function.</P>
<P>But, by popular demand, here is an in-depth example. Unfortunately, =
the=20
difference between the dirt-simple example, above, and this one here is=20
significant. But have a look, then read the description that follows =
it.</P>
<P><A href=3D"http://beej.us/guide/bgnet/examples/selectserver.c">This =
program</A>=20
acts like a simple multi-user chat server. Start it running in one =
window, then=20
<B><TT>telnet</TT></B> to it ("<B><TT>telnet hostname 9034</TT></B>") =
from=20
multiple other windows. When you type something in one =
<B><TT>telnet</TT></B>=20
session, it should appear in all the others.</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>/*
** selectserver.c -- a cheezy multiperson chat server
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define PORT 9034   // port we're listening on

int main(void)
{
    fd_set master;   // master file descriptor list
    fd_set read_fds; // temp file descriptor list for select()
    struct sockaddr_in myaddr;     // server address
    struct sockaddr_in remoteaddr; // client address
    int fdmax;        // maximum file descriptor number
    int listener;     // listening socket descriptor
    int newfd;        // newly accept()ed socket descriptor
    char buf[256];    // buffer for client data
    int nbytes;
    int yes=3D1;        // for setsockopt() SO_REUSEADDR, below
    socklen_t addrlen;
    int i, j;

    FD_ZERO(&amp;master);    // clear the master and temp sets
    FD_ZERO(&amp;read_fds);

    // get the listener
    if ((listener =3D socket(PF_INET, SOCK_STREAM, 0)) =3D=3D -1) {
        perror("socket");
        exit(1);
    }

    // lose the pesky "address already in use" error message
    if (setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes,
                                                        sizeof(int)) =
=3D=3D -1) {
        perror("setsockopt");
        exit(1);
    }

    // bind
    myaddr.sin_family =3D AF_INET;
    myaddr.sin_addr.s_addr =3D INADDR_ANY;
    myaddr.sin_port =3D htons(PORT);
    memset(&amp;(myaddr.sin_zero), '\0', 8);
    if (bind(listener, (struct sockaddr *)&amp;myaddr, sizeof(myaddr)) =
=3D=3D -1) {
        perror("bind");
        exit(1);
    }

    // listen
    if (listen(listener, 10) =3D=3D -1) {
        perror("listen");
        exit(1);
    }

    // add the listener to the master set
    FD_SET(listener, &amp;master);

    // keep track of the biggest file descriptor
    fdmax =3D listener; // so far, it's this one

    // main loop
    for(;;) {
        read_fds =3D master; // copy it
        if (select(fdmax+1, &amp;read_fds, NULL, NULL, NULL) =3D=3D -1) =
{
            perror("select");
            exit(1);
        }

        // run through the existing connections looking for data to read
        for(i =3D 0; i &lt;=3D fdmax; i++) {
            if (FD_ISSET(i, &amp;read_fds)) { // we got one!!
                if (i =3D=3D listener) {
                    // handle new connections
                    addrlen =3D sizeof(remoteaddr);
                    if ((newfd =3D accept(listener, (struct sockaddr =
*)&amp;remoteaddr,
                                                             =
&amp;addrlen)) =3D=3D -1) {=20
                        perror("accept");
                    } else {
                        FD_SET(newfd, &amp;master); // add to master set
                        if (newfd &gt; fdmax) {    // keep track of the =
maximum
                            fdmax =3D newfd;
                        }
                        printf("selectserver: new connection from %s on =
"
                            "socket %d\n", =
inet_ntoa(remoteaddr.sin_addr), newfd);
                    }
                } else {
                    // handle data from a client
                    if ((nbytes =3D recv(i, buf, sizeof(buf), 0)) =
&lt;=3D 0) {
                        // got error or connection closed by client
                        if (nbytes =3D=3D 0) {
                            // connection closed
                            printf("selectserver: socket %d hung up\n", =
i);
                        } else {
                            perror("recv");
                        }
                        close(i); // bye!
                        FD_CLR(i, &amp;master); // remove from master =
set
                    } else {
                        // we got some data from a client
                        for(j =3D 0; j &lt;=3D fdmax; j++) {
                            // send to everyone!
                            if (FD_ISSET(j, &amp;master)) {
                                // except the listener and ourselves
                                if (j !=3D listener &amp;&amp; j !=3D i) =
{
                                    if (send(j, buf, nbytes, 0) =3D=3D =
-1) {
                                        perror("send");
                                    }
                                }
                            }
                        }
                    }
                } // it's SO UGLY!
            }
        }
    }
   =20
    return 0;
}=20
</PRE></TR></TBODY></TABLE></P>
<P>Notice I have two file descriptor sets in the code: =
<I><TT>master</TT></I>=20
and <I><TT>read_fds</TT></I>. The first, <I><TT>master</TT></I>, holds =
all the=20
socket descriptors that are currently connected, as well as the socket=20
descriptor that is listening for new connections.</P>
<P>The reason I have the <I><TT>master</TT></I> set is that =
<TT>select()</TT>=20
actually <I>changes</I> the set you pass into it to reflect which =
sockets are=20
ready to read. Since I have to keep track of the connections from one =
call of=20
<TT>select()</TT> to the next, I must store these safely away somewhere. =
At the=20
last minute, I copy the <I><TT>master</TT></I> into the=20
<I><TT>read_fds</TT></I>, and then call <TT>select()</TT>.</P>
<P>But doesn't this mean that every time I get a new connection, I have =
to add=20
it to the <I><TT>master</TT></I> set? Yup! And every time a connection =
closes, I=20
have to remove it from the <I><TT>master</TT></I> set? Yes, it does.</P>
<P>Notice I check to see when the <I><TT>listener</TT></I> socket is =
ready to=20
read. When it is, it means I have a new connection pending, and I=20
<TT>accept()</TT> it and add it to the <I><TT>master</TT></I> set. =
Similarly,=20
when a client connection is ready to read, and <TT>recv()</TT> returns=20
<B><TT>0</TT></B>, I know the client has closed the connection, and I =
must=20
remove it from the <I><TT>master</TT></I> set.</P>
<P>If the client <TT>recv()</TT> returns non-zero, though, I know some =
data has=20
been received. So I get it, and then go through the =
<I><TT>master</TT></I> list=20
and send that data to all the rest of the connected clients.</P>
<P>And that, my friends, is a less-than-simple overview of the almighty=20
<TT>select()</TT> function.</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  sendall  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>6.3. <A name=3Dsendall>Handling Partial <TT>send()</TT>s</A></H3>
<P></P>
<P>Remember back in the <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendrecv"=
>section=20
about <TT>send()</TT></A>, above, when I said that <TT>send()</TT> might =
not=20
send all the bytes you asked it to? That is, you want it to send 512 =
bytes, but=20
it returns 412. What happened to the remaining 100 bytes?</P>
<P>Well, they're still in your little buffer waiting to be sent out. Due =
to=20
circumstances beyond your control, the kernel decided not to send all =
the data=20
out in one chunk, and now, my friend, it's up to you to get the data out =

there.</P>
<P>You could write a function like this to do it, too:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int sendall(int s, char *buf, int *len)
{
    int total =3D 0;        // how many bytes we've sent
    int bytesleft =3D *len; // how many we have left to send
    int n;

    while(total &lt; *len) {
        n =3D send(s, buf+total, bytesleft, 0);
        if (n =3D=3D -1) { break; }
        total +=3D n;
        bytesleft -=3D n;
    }

    *len =3D total; // return number actually sent here

    return n=3D=3D-1?-1:0; // return -1 on failure, 0 on success
}=20
</PRE></TR></TBODY></TABLE></P>
<P>In this example, <I><TT>s</TT></I> is the socket you want to send the =
data=20
to, <I><TT>buf</TT></I> is the buffer containing the data, and=20
<I><TT>len</TT></I> is a pointer to an <TT>int</TT> containing the =
number of=20
bytes in the buffer.</P>
<P>The function returns <B><TT>-1</TT></B> on error (and =
<I><TT>errno</TT></I>=20
is still set from the call to <TT>send()</TT>.) Also, the number of =
bytes=20
actually sent is returned in <I><TT>len</TT></I>. This will be the same =
number=20
of bytes you asked it to send, unless there was an error. =
<TT>sendall()</TT>=20
will do it's best, huffing and puffing, to send the data out, but if =
there's an=20
error, it gets back to you right away.</P>
<P>For completeness, here's a sample call to the function:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>char buf[10] =3D "Beej!";
int len;

len =3D strlen(buf);
if (sendall(s, buf, &amp;len) =3D=3D -1) {
    perror("sendall");
    printf("We only sent %d bytes because of the error!\n", len);
}=20
</PRE></TR></TBODY></TABLE></P>
<P>What happens on the receiver's end when part of a packet arrives? If =
the=20
packets are variable length, how does the receiver know when one packet =
ends and=20
another begins? Yes, real-world scenarios are a royal pain in the =
donkeys. You=20
probably have to <I>encapsulate</I> (remember that from the <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#lowlevel"=
>data=20
encapsulation section</A> way back there at the beginning?) Read on for=20
details!</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  sonofdataencap  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>6.4. <A name=3Dsonofdataencap>Son of Data Encapsulation</A></H3>
<P></P>
<P>What does it really mean to encapsulate data, anyway? In the simplest =
case,=20
it means you'll stick a header on there with either some identifying =
information=20
or a packet length, or both.</P>
<P>What should your header look like? Well, it's just some binary data =
that=20
represents whatever you feel is necessary to complete your project.</P>
<P>Wow. That's vague.</P>
<P>Okay. For instance, let's say you have a multi-user chat program that =
uses=20
<B><TT>SOCK_STREAM</TT></B>s. When a user types ("says") something, two =
pieces=20
of information need to be transmitted to the server: what was said and =
who said=20
it.</P>
<P>So far so good? "What's the problem?" you're asking.</P>
<P>The problem is that the messages can be of varying lengths. One =
person named=20
"tom" might say, "Hi", and another person named "Benjamin" might say, =
"Hey guys=20
what is up?"</P>
<P>So you <TT>send()</TT> all this stuff to the clients as it comes in. =
Your=20
outgoing data stream looks like this:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>t o m H i B e n j a m i n H e y g u y s w =
h a t i s u p ?
</PRE></TR></TBODY></TABLE></P>
<P>And so on. How does the client know when one message starts and =
another=20
stops? You could, if you wanted, make all messages the same length and =
just call=20
the <TT>sendall()</TT> we implemented, <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendall">=
above</A>.=20
But that wastes bandwidth! We don't want to <TT>send()</TT> 1024 bytes =
just so=20
"tom" can say "Hi".</P>
<P>So we <I>encapsulate</I> the data in a tiny header and packet =
structure. Both=20
the client and server know how to pack and unpack (sometimes referred to =
as=20
"marshal" and "unmarshal") this data. Don't look now, but we're starting =
to=20
define a <I>protocol</I> that describes how a client and server =
communicate!</P>
<P>In this case, let's assume the user name is a fixed length of 8 =
characters,=20
padded with <B><TT>'\0'</TT></B>. And then let's assume the data is =
variable=20
length, up to a maximum of 128 characters. Let's have a look a sample =
packet=20
structure that we might use in this situation:</P>
<OL>
  <LI><TT>len</TT> (1 byte, unsigned) -- The total length of the packet, =

  counting the 8-byte user name and chat data.=20
  <LI><TT>name</TT> (8 bytes) -- The user's name, NUL-padded if =
necessary.=20
  <LI><TT>chatdata</TT> (<I>n</I>-bytes) -- The data itself, no more =
than 128=20
  bytes. The length of the packet should be calculated as the length of =
this=20
  data plus 8 (the length of the name field, above). </LI></OL>
<P>Why did I choose the 8-byte and 128-byte limits for the fields? I =
pulled them=20
out of the air, assuming they'd be long enough. Maybe, though, 8 bytes =
is too=20
restrictive for your needs, and you can have a 30-byte name field, or =
whatever.=20
The choice is up to you.</P>
<P>Using the above packet definition, the first packet would consist of =
the=20
following information (in hex and ASCII):</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>   0A     74 6F 6D 00 00 00 00 00      48 =
69
 (length)  T  o  m    (padding)         H  i
</PRE></TR></TBODY></TABLE></P>
<P>And the second is similar:</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>   14     42 65 6E 6A 61 6D 69 6E      48 =
65 79 20 67 75 79 73 20 77 ...
 (length)  B  e  n  j  a  m  i  n       H  e  y     g  u  y  s     w ...
</PRE></TR></TBODY></TABLE></P>
<P>(The length is stored in Network Byte Order, of course. In this case, =
it's=20
only one byte so it doesn't matter, but generally speaking you'll want =
all your=20
binary integers to be stored in Network Byte Order in your packets.)</P>
<P>When you're sending this data, you should be safe and use a command =
similar=20
to <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendall">=
<TT>sendall()</TT></A>,=20
above, so you know all the data is sent, even if it takes multiple calls =
to=20
<TT>send()</TT> to get it all out.</P>
<P>Likewise, when you're receiving this data, you need to do a bit of =
extra=20
work. To be safe, you should assume that you might receive a partial =
packet=20
(like maybe we receive "<TT>14 42 65 6E</TT>" from Benjamin, above, but =
that's=20
all we get in this call to <TT>recv()</TT>). We need to call =
<TT>recv()</TT>=20
over and over again until the packet is completely received.</P>
<P>But how? Well, we know the number of bytes we need to receive in =
total for=20
the packet to be complete, since that number is tacked on the front of =
the=20
packet. We also know the maximum packet size is 1+8+128, or 137 bytes =
(because=20
that's how we defined the packet.)</P>
<P>What you can do is declare an array big enough for two packets. This =
is your=20
work array where you will reconstruct packets as they arrive.</P>
<P>Every time you <TT>recv()</TT> data, you'll feed it into the work =
buffer and=20
check to see if the packet is complete. That is, the number of bytes in =
the=20
buffer is greater than or equal to the length specified in the header =
(+1,=20
because the length in the header doesn't include the byte for the length =

itself.) If the number of bytes in the buffer is less than 1, the packet =
is not=20
complete, obviously. You have to make a special case for this, though, =
since the=20
first byte is garbage and you can't rely on it for the correct packet=20
length.</P>
<P>Once the packet is complete, you can do with it what you will. Use =
it, and=20
remove it from your work buffer.</P>
<P>Whew! Are you juggling that in your head yet? Well, here's the second =
of the=20
one-two punch: you might have read past the end of one packet and onto =
the next=20
in a single <TT>recv()</TT> call. That is, you have a work buffer with =
one=20
complete packet, and an incomplete part of the next packet! Bloody heck. =
(But=20
this is why you made your work buffer large enough to hold <I>two</I>=20
packets--in case this happened!)</P>
<P>Since you know the length of the first packet from the header, and =
you've=20
been keeping track of the number of bytes in the work buffer, you can =
subtract=20
and calculate how many of the bytes in the work buffer belong to the =
second=20
(incomplete) packet. When you've handled the first one, you can clear it =
out of=20
the work buffer and move the partial second packed down the to front of =
the=20
buffer so it's all ready to go for the next <TT>recv()</TT>.</P>
<P>(Some of you readers will note that actually moving the partial =
second packet=20
to the beginning of the work buffer takes time, and the program can be =
coded to=20
not require this by using a circular buffer. Unfortunately for the rest =
of you,=20
a discussion on circular buffers is beyond the scope of this article. If =
you're=20
still curious, grab a data structures book and go from there.)</P>
<P>I never said it was easy. Ok, I did say it was easy. And it is; you =
just need=20
practice and pretty soon it'll come to you naturally. By Excalibur I =
swear=20
it!</P><!--  sonofdataencap  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  broadcast  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>6.5. <A name=3Dbroadcast>Broadcast Packets--Hello, World!</A></H3>
<P></P>
<P>So far, this guide has talked about sending data from one host to one =
other=20
host. But it is possible, I insist, that you can, with the proper =
authority,=20
send data to multiple hosts <I>at the same time</I>!</P>
<P>With UDP (only UDP, not TCP) and standard IPv4, this is done through =
a=20
mechanism called <I>broadcasting</I>. With IPv6 (not appearing in this=20
guide...yet), broadcasting isn't supported, and you have to resort to =
the often=20
superior technique of <I>multicasting</I>. But enough of the starry-eyed =

future--we're stuck in the 32-bit present.</P>
<P>But wait! You can't just run off and start broadcasting willy-nilly; =
You have=20
to set the socket option <B><TT>SO_BROADCAST</TT></B> before you can =
send a=20
broadcast packet out on the network. It's like a one of those little =
plastic=20
covers they put over the missile launch switch! That's just how much =
power you=20
hold in your hands!</P>
<P>But seriously, though, there is a danger to using broadcast packets, =
and that=20
is: every system that recieves a broadcast packet must undo all the =
onion-skin=20
layers of data encapsulation until it finds out what port the data is =
destined=20
to. And then it hands the data over or discards it. In either case, it's =
a lot=20
of work for each machine that recieves the broadcast packet, and since =
it is all=20
of them on the local network, that could be a lot of machines doing a =
lot of=20
unnecessary work. When the game Doom first came out, this was a =
complaint about=20
its network code.</P>
<P>Yes, I said the local network. There is more than one way to skin a =
cat...=20
wait a minute. Is there really more than one way to skin a cat? What =
kind of=20
expression is that? Uh, and likewise, there is more than one way to send =
a=20
broadcast packet, but the broadcast packets will usually be restricted =
to your=20
local network no matter how you send them.</P>
<P>So now to the meat and potatoes of the whole thing: how do you =
specify the=20
destination address for a broadcast message? There are two common =
ways.</P>
<OL>
  <LI>Send the data to your broadcast address. This is your network =
number with=20
  all one-bits set for the host portion of the address. For instance, at =
home my=20
  network is 192.168.1.0, my netmask is 255.255.255.0, so the last byte =
of the=20
  address is my host number (because the first three bytes, according to =
the=20
  netmask, are the network number). So my broadcast address is =
192.168.1.255.=20
  Under Unix, the <B><TT>ifconfig</TT></B> command will actually give =
you all=20
  this data. (If you're curious, the bitwise logic to get your broadcast =
address=20
  is <B><TT>network_number</TT></B> OR (NOT <B><TT>netmask</TT></B>).)=20
  <LI>Send the data to the "global" broadcast address. This is =
255.255.255.255,=20
  aka <B><TT>INADDR_BROADCAST</TT></B>. Many machines will automatically =
bitwise=20
  AND this with your network number to convert it to a network broadcast =

  address, but some won't. It varies. </LI></OL>
<P>So what happens if you try to send data on the broadcast address =
without=20
first setting the <B><TT>SO_BROADCAST</TT></B> socket option? Well, =
let's fire=20
up good old <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#datagram"=
><B><TT>talker</TT></B>=20
and <B><TT>listener</TT></B></A> and see what happens.</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>$ talker 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ talker 192.168.1.255 foo
sendto: Permission denied
$ talker 255.255.255.255 foo
sendto: Permission denied
</PRE></TR></TBODY></TABLE></P>
<P>Yes, it's not happy at all...because we didn't set the=20
<B><TT>SO_BROADCAST</TT></B> socket option. Do that, and now you can=20
<TT>sendto()</TT> anywhere you want!</P>
<P>In fact, that's the <I>only difference</I> between a UDP application =
that can=20
broadcast and one that can't. So let's take the old =
<B><TT>talker</TT></B>=20
application and add one section that sets the =
<B><TT>SO_BROADCAST</TT></B>=20
socket option. We'll call this program <A=20
href=3D"http://beej.us/guide/bgnet/examples/broadcaster.c"><I><TT>broadca=
ster.c</TT></I></A>:</P><!--  BEGIN broadcaster.c  -->
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>/*
** broadcaster.c -- a datagram "client" like talker.c, except
**                  this one can broadcast
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT 4950    // the port users will be connecting to

int main(int argc, char *argv[])
{
    int sockfd;
    struct sockaddr_in their_addr; // connector's address information
    struct hostent *he;
    int numbytes;
    int broadcast =3D 1;
    //char broadcast =3D '1'; // if that doesn't work, try this

    if (argc !=3D 3) {
        fprintf(stderr,"usage: broadcaster hostname message\n");
        exit(1);
    }

    if ((he=3Dgethostbyname(argv[1])) =3D=3D NULL) {  // get the host =
info
        perror("gethostbyname");
        exit(1);
    }

    if ((sockfd =3D socket(AF_INET, SOCK_DGRAM, 0)) =3D=3D -1) {
        perror("socket");
        exit(1);
    }

    // this call is the difference between this program and talker.c:
    if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;broadcast,
        sizeof(broadcast)) =3D=3D -1) {
        perror("setsockopt (SO_BROADCAST)");
        exit(1);
    }

    their_addr.sin_family =3D AF_INET;     // host byte order
    their_addr.sin_port =3D htons(SERVERPORT); // short, network byte =
order
    their_addr.sin_addr =3D *((struct in_addr *)he-&gt;h_addr);
    memset(&amp;(their_addr.sin_zero), '\0', 8);  // zero the rest of =
the struct

    if ((numbytes=3Dsendto(sockfd, argv[2], strlen(argv[2]), 0,
             (struct sockaddr *)&amp;their_addr, sizeof(struct =
sockaddr))) =3D=3D -1) {
        perror("sendto");
        exit(1);
    }

    printf("sent %d bytes to %s\n", numbytes, =
inet_ntoa(their_addr.sin_addr));

    close(sockfd);

    return 0;
}</PRE></TR></TBODY></TABLE></P><!--  END broadcaster.c  -->
<P>What's different between this and a "normal" UDP client/server =
situation?=20
Nothing! (With the exception of the client being allowed to send =
broadcast=20
packets in this case.) As such, go ahead and run the old UDP <A=20
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#datagram"=
><B><TT>listener</TT></B></A>=20
program in one window, and <B><TT>broadcaster</TT></B> in another. You =
should be=20
now be able to do all those sends that failed, above.</P>
<P>
<TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
  <TBODY>
  <TR>
    <TD bgColor=3D#cfcfcf><PRE>$ talker 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ talker 192.168.1.255 foo
sent 3 bytes to 192.168.1.255
$ talker 255.255.255.255 foo
sent 3 bytes to 255.255.255.255
</PRE></TR></TBODY></TABLE></P>
<P>And you should see <B><TT>listener</TT></B> responding that it got =
the=20
packets.</P>
<P>Well, that's kind of exciting. But now fire up =
<B><TT>listener</TT></B> on=20
another machine next to you on the same network so that you have two =
copies=20
going, one on each machine, and run <B><TT>broadcaster</TT></B> again =
with your=20
broadcast address... Hey! Both <B><TT>listener</TT></B>s get the packet =
even=20
though you only called <TT>sendto()</TT> once! Cool!</P>
<P>If the <B><TT>listener</TT></B> gets data you send directly to it, =
but not=20
data on the broadcast address, it could be that you have a firewall on =
your=20
local machine that is blocking the packets. (Yes, Pat and Bapper, thank =
you for=20
realizing before I did that this is why my sample code wasn't working. I =
told=20
you I'd mention you in the guide, and here you are. So <I>nyah</I>.)</P>
<P>Again, be careful with broadcast packets. Since every machine on the =
LAN will=20
be forced to deal with the packet whether it <TT>recvfrom()</TT>s it or =
not, it=20
can present quite a load to the entire computing network. They are =
definitely to=20
be used sparingly and appropriately.</P><!--  broadcast  --><!--  =
advanced  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  faq  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<HR>

<H2>7. <A name=3Dfaq>Common Questions</A></H2>
<P></P>
<DL><!--  +++++++++++++++++++++++++  -->
  <DT><B>Where can I get those header files?</B>=20
  <DD>
  <P>If you don't have them on your system already, you probably don't =
need=20
  them. Check the manual for your particular platform. If you're =
building for=20
  Windows, you only need to <TT>#include &lt;winsock.h&gt;</TT>.</P><!-- =
 +++++++++++++++++++++++++  -->
  <DT><B>What do I do when <TT>bind()</TT> reports "Address already in =
use"?</B>=20

  <DD>
  <P>You have to use <TT>setsockopt()</TT> with the =
<B><TT>SO_REUSEADDR</TT></B>=20
  option on the listening socket. Check out the <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#bind">sec=
tion on=20
  <TT>bind()</TT></A> and the <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#select">s=
ection=20
  on <TT>select()</TT></A> for an example.</P><!--  =
+++++++++++++++++++++++++  -->
  <DT><B>How do I get a list of open sockets on the system?</B>=20
  <DD>
  <P>Use the <B><TT>netstat</TT></B>. Check the <B><TT>man</TT></B> page =
for=20
  full details, but you should get some good output just typing:</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>$ netstat
</PRE></TR></TBODY></TABLE></P>
  <P>The only trick is determining which socket is associated with which =

  program. <TT>:-)</TT></P><!--  +++++++++++++++++++++++++  -->
  <DT><B>How can I view the routing table?</B>=20
  <DD>
  <P>Run the <B><TT>route</TT></B> command (in <I><TT>/sbin</TT></I> on =
most=20
  Linuxes) or the command <B><TT>netstat -r</TT></B>.</P><!--  =
+++++++++++++++++++++++++  -->
  <DT><B>How can I run the client and server programs if I only have one =

  computer? Don't I need a network to write network program?</B>=20
  <DD>
  <P>Fortunately for you, virtually all machines implement a loopback =
network=20
  "device" that sits in the kernel and pretends to be a network card. =
(This is=20
  the interface listed as "<TT>lo</TT>" in the routing table.)</P>
  <P>Pretend you're logged into a machine named "<TT>goat</TT>". Run the =
client=20
  in one window and the server in another. Or start the server in the =
background=20
  ("<B><TT>server &amp;</TT></B>") and run the client in the same =
window. The=20
  upshot of the loopback device is that you can either <B><TT>client=20
  goat</TT></B> or <B><TT>client localhost</TT></B> (since =
"<TT>localhost</TT>"=20
  is likely defined in your <I><TT>/etc/hosts</TT></I> file) and you'll =
have the=20
  client talking to the server without a network!</P>
  <P>In short, no changes are necessary to any of the code to make it =
run on a=20
  single non-networked machine! Huzzah!</P><!--  =
+++++++++++++++++++++++++  -->
  <DT><B>How can I tell if the remote side has closed connection?</B>=20
  <DD>
  <P>You can tell because <TT>recv()</TT> will return =
<B><TT>0</TT></B>.</P><!--  +++++++++++++++++++++++++  -->
  <DT><B>How do I implement a "ping" utility? What is ICMP? Where can I =
find out=20
  more about raw sockets and <B><TT>SOCK_RAW</TT></B>?</B>=20
  <DD>
  <P>All your raw sockets questions will be answered in W. Richard =
Stevens' UNIX=20
  Network Programming books. See the <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#books">bo=
oks</A>=20
  section of this guide.</P><!--  +++++++++++++++++++++++++  -->
  <DT><B>How do I build for Windows?</B>=20
  <DD>
  <P>First, delete Windows and install Linux or BSD. <TT>};-)</TT>. No,=20
  actually, just see the <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#windows">=
section=20
  on building for Windows</A> in the introduction.</P><!--  =
+++++++++++++++++++++++++  -->
  <DT><B>How do I build for Solaris/SunOS? I keep getting linker errors =
when I=20
  try to compile!</B>=20
  <DD>
  <P>The linker errors happen because Sun boxes don't automatically =
compile in=20
  the socket libraries. See the <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#solaris">=
section=20
  on building for Solaris/SunOS</A> in the introduction for an example =
of how to=20
  do this.</P><!--  +++++++++++++++++++++++++  -->
  <DT><B>Why does <TT>select()</TT> keep falling out on a signal?</B>=20
  <DD>
  <P>Signals tend to cause blocked system calls to return =
<B><TT>-1</TT></B>=20
  with <I><TT>errno</TT></I> set to <B><TT>EINTR</TT></B>. When you set =
up a=20
  signal handler with <TT>sigaction()</TT>, you can set the flag=20
  <B><TT>SA_RESTART</TT></B>, which is supposed to restart the system =
call after=20
  it was interrupted.</P>
  <P>Naturally, this doesn't always work.</P>
  <P>My favorite solution to this involves a <TT>goto</TT> statement. =
You know=20
  this irritates your professors to no end, so go for it!</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>select_restart:
if ((err =3D select(fdmax+1, &amp;readfds, NULL, NULL, NULL)) =3D=3D -1) =
{
    if (errno =3D=3D EINTR) {
        // some signal just interrupted us, so restart
        goto select_restart;
    }
    // handle the real error here:
    perror("select");
}=20
</PRE></TR></TBODY></TABLE></P>
  <P>Sure, you don't <I>need</I> to use <TT>goto</TT> in this case; you =
can use=20
  other structures to control it. But I think the <TT>goto</TT> =
statement is=20
  actually cleaner.</P><!--  +++++++++++++++++++++++++  -->
  <DT><B>How can I implement a timeout on a call to <TT>recv()</TT>?</B> =

  <DD>
  <P>Use <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#select"><=
TT>select()</TT></A>!=20
  It allows you to specify a timeout parameter for socket descriptors =
that=20
  you're looking to read from. Or, you could wrap the entire =
functionality in a=20
  single function, like this:</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int recvtimeout(int s, char *buf, int len, int timeout)
{
    fd_set fds;
    int n;
    struct timeval tv;

    // set up the file descriptor set
    FD_ZERO(&amp;fds);
    FD_SET(s, &amp;fds);

    // set up the struct timeval for the timeout
    tv.tv_sec =3D timeout;
    tv.tv_usec =3D 0;

    // wait until timeout or data received
    n =3D select(s+1, &amp;fds, NULL, NULL, &amp;tv);
    if (n =3D=3D 0) return -2; // timeout!
    if (n =3D=3D -1) return -1; // error

    // data must be here, so do a normal recv()
    return recv(s, buf, len, 0);
}
.
.
.
// Sample call to recvtimeout():
n =3D recvtimeout(s, buf, sizeof(buf), 10); // 10 second timeout

if (n =3D=3D -1) {
    // error occurred
    perror("recvtimeout");
}
else if (n =3D=3D -2) {
    // timeout occurred
} else {
    // got some data in buf
}
.
.
.=20
</PRE></TR></TBODY></TABLE></P>
  <P>Notice that <TT>recvtimeout()</TT> returns <B><TT>-2</TT></B> in =
case of a=20
  timeout. Why not return <B><TT>0</TT></B>? Well, if you recall, a =
return value=20
  of <B><TT>0</TT></B> on a call to <TT>recv()</TT> means that the =
remote side=20
  closed the connection. So that return value is already spoken for, and =

  <B><TT>-1</TT></B> means "error", so I chose <B><TT>-2</TT></B> as my =
timeout=20
  indicator.</P><!--  +++++++++++++++++++++++++  --><!--  already =
answered, above=0A=
<faqentry>=0A=
=0A=
<q>What if I only have one computer and no network?  How is=0A=
it possible to write and test sockets programs?</q>=0A=
=0A=
<a><p>It will work on a single computer exactly the same way that it=0A=
works on a networked computer.</p>=0A=
=0A=
<p>That is, running the client and server on the same machine works=0A=
just as well as running them on different machines, and you don't even=0A=
have to think about the difference.</p>=0A=
=0A=
<p>You can get the answer as to why this is the case if you type=0A=
"<com>route</com>":</p>=0A=
=0A=
<screen>=0A=
$ route=0A=
Kernel IP routing table=0A=
Destination     Gateway         Genmask         Flags Metric Ref    Use =
Iface=0A=
10.0.0.0        *               255.0.0.0       U     0      0        0 =
eth0=0A=
127.0.0.0       *               255.0.0.0       U     0      0        0 =
lo=0A=
default         mygateway       0.0.0.0         UG    0      0        0 =
eth0=0A=
</screen>=0A=
=0A=
<p>See, all the traffic on <tt>10.x.x.x</tt>=0A=
goes to my local subnet via <tt>eth0</tt> (the=0A=
network card), but all traffic to the=0A=
<tt>127.x.x.x</tt> subnet goes to the=0A=
<tt>lo</tt>=0A=
interface (loopback&emdash;a fake "network card" inside the kernel that=0A=
handles traffic from one machine to itself.)</p>=0A=
=0A=
<p>The <tt>lo</tt> interface is also used=0A=
when you try to telnet to your own IP address (at least under Linux).=0A=
So from host "frog" I can either "<com>telnet frog</com>", or=0A=
"<com>telnet localhost</com>"&emdash;localhost is=0A=
<tt>127.0.0.1</tt>&emdash;and it will use=0A=
<tt>lo</tt>.)</p>=0A=
=0A=
<p>So in short, don't worry about it.  The client and server will=0A=
run on the same machine just fine.</p>=0A=
=0A=
</a>=0A=
=0A=
</faqentry>=0A=
 --><!--  +++++++++++++++++++++++++  -->
  <DT><B>How do I encrypt or compress the data before sending it through =
the=20
  socket?</B>=20
  <DD>
  <P>One easy way to do encryption is to use SSL (secure sockets layer), =
but=20
  that's beyond the scope of this guide.</P>
  <P>But assuming you want to plug in or implement your own compressor =
or=20
  encryption system, it's just a matter of thinking of your data as =
running=20
  through a sequence of steps between both ends. Each step changes the =
data in=20
  some way.</P>
  <OL>
    <LI>server reads data from file (or whereever)=20
    <LI>server encrypts data (you add this part)=20
    <LI>server <TT>send()</TT>s encrypted data </LI></OL>
  <P>Now the other way around:</P>
  <OL>
    <LI>client <TT>recv()</TT>s encrypted data=20
    <LI>client decrypts data (you add this part)=20
    <LI>client writes data to file (or whereever) </LI></OL>
  <P>You can also do compression at the same point that you do the=20
  encryption/decryption, above. Or you could do both! Just remember to =
compress=20
  before you encrypt. <TT>:)</TT></P>
  <P>Just as long as the client properly undoes what the server does, =
the data=20
  will be fine in the end no matter how many intermediate steps you =
add.</P>
  <P>So all you need to do to use my code is to find the place between =
where the=20
  data is read and the data is sent (using <TT>send()</TT>) over the =
network,=20
  and stick some code in there that does the encryption.</P><!--  =
+++++++++++++++++++++++++  -->
  <DT><B>What is this "<B><TT>PF_INET</TT></B>" I keep seeing? Is it =
related to=20
  <B><TT>AF_INET</TT></B>?</B>=20
  <DD>
  <P>Yes, yes it is. See <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#socket">t=
he=20
  section on <TT>socket()</TT></A> for details.</P><!--  =
+++++++++++++++++++++++++  -->
  <DT><B>How can I write a server that accepts shell commands from a =
client and=20
  executes them?</B>=20
  <DD>
  <P>For simplicity, lets say the client <TT>connect()</TT>s, =
<TT>send()</TT>s,=20
  and <TT>close()</TT>s the connection (that is, there are no subsequent =
system=20
  calls without the client connecting again.)</P>
  <P>The process the client follows is this:</P>
  <OL>
    <LI><TT>connect()</TT> to server=20
    <LI><TT>send("/sbin/ls &gt; /tmp/client.out")</TT>=20
    <LI><TT>close()</TT> the connection </LI></OL>
  <P>Meanwhile, the server is handling the data and executing it:</P>
  <OL>
    <LI><TT>accept()</TT> the connection from the client=20
    <LI><TT>recv(str)</TT> the command string=20
    <LI><TT>close()</TT> the connection=20
    <LI><TT>system(str)</TT> to run the command </LI></OL>
  <P><I>Beware!</I> Having the server execute what the client says is =
like=20
  giving remote shell access and people can do things to your account =
when they=20
  connect to the server. For instance, in the above example, what if the =
client=20
  sends "<B><TT>rm -rf ~</TT></B>"? It deletes everything in your =
account,=20
  that's what!</P>
  <P>So you get wise, and you prevent the client from using any except =
for a=20
  couple utilities that you know are safe, like the =
<B><TT>foobar</TT></B>=20
  utility:</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>if (!strcmp(str, "foobar")) {
    sprintf(sysstr, "%s &gt; /tmp/server.out", str);
    system(sysstr);
}=20
</PRE></TR></TBODY></TABLE></P>
  <P>But you're still unsafe, unfortunately: what if the client enters=20
  "<B><TT>foobar; rm -rf ~</TT></B>"? The safest thing to do is to write =
a=20
  little routine that puts an escape ("<B><TT>\</TT></B>") character in =
front of=20
  all non-alphanumeric characters (including spaces, if appropriate) in =
the=20
  arguments for the command.</P>
  <P>As you can see, security is a pretty big issue when the server =
starts=20
  executing things the client sends.</P><!--  +++++++++++++++++++++++++  =
-->
  <DT><B>I'm sending a slew of data, but when I <TT>recv()</TT>, it only =

  receives 536 bytes or 1460 bytes at a time. But if I run it on my =
local=20
  machine, it receives all the data at the same time. What's going =
on?</B>=20
  <DD>
  <P>You're hitting the MTU--the maximum size the physical medium can =
handle. On=20
  the local machine, you're using the loopback device which can handle =
8K or=20
  more no problem. But on ethernet, which can only handle 1500 bytes =
with a=20
  header, you hit that limit. Over a modem, with 576 MTU (again, with =
header),=20
  you hit the even lower limit.</P>
  <P>You have to make sure all the data is being sent, first of all. =
(See the <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendall">=
<TT>sendall()</TT></A>=20
  function implementation for details.) Once you're sure of that, then =
you need=20
  to call <TT>recv()</TT> in a loop until all your data is read.</P>
  <P>Read the section <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sonofdata=
encap">Son=20
  of Data Encapsulation</A> for details on receiving complete packets of =
data=20
  using multiple calls to <TT>recv()</TT>.</P><!--  =
+++++++++++++++++++++++++  -->
  <DT><B>I'm on a Windows box and I don't have the <TT>fork()</TT> =
system call=20
  or any kind of <TT>struct sigaction</TT>. What to do?</B>=20
  <DD>
  <P>If they're anywhere, they'll be in POSIX libraries that may have =
shipped=20
  with your compiler. Since I don't have a Windows box, I really can't =
tell you=20
  the answer, but I seem to remember that Microsoft has a POSIX =
compatibility=20
  layer and that's where <TT>fork()</TT> would be. (And maybe even=20
  <TT>sigaction</TT>.)</P>
  <P>Search the help that came with VC++ for "fork" or "POSIX" and see =
if it=20
  gives you any clues.</P>
  <P>If that doesn't work at all, ditch the =
<TT>fork()</TT>/<TT>sigaction</TT>=20
  stuff and replace it with the Win32 equivalent: =
<TT>CreateProcess()</TT>. I=20
  don't know how to use <TT>CreateProcess()</TT>--it takes a bazillion=20
  arguments, but it should be covered in the docs that came with =
VC++.</P><!--  +++++++++++++++++++++++++  -->
  <DT><B>How do I send data securely with TCP/IP using encryption?</B>=20
  <DD>
  <P>Check out the <A href=3D"http://www.openssl.org/">OpenSSL =
project</A>.</P><!--  +++++++++++++++++++++++++  -->
  <DT><B>I'm behind a firewall--how do I let people outside the firewall =
know my=20
  IP address so they can connect to my machine?</B>=20
  <DD>
  <P>Unfortunately, the purpose of a firewall is to prevent people =
outside the=20
  firewall from connecting to machines inside the firewall, so allowing =
them to=20
  do so is basically considered a breach of security.</P>
  <P>This isn't to say that all is lost. For one thing, you can still =
often=20
  <TT>connect()</TT> through the firewall if it's doing some kind of=20
  masquerading or NAT or something like that. Just design your programs =
so that=20
  you're always the one initiating the connection, and you'll be =
fine.</P>
  <P>If that's not satisfactory, you can ask your sysadmins to poke a =
hole in=20
  the firewall so that people can connect to you. The firewall can =
forward to=20
  you either through it's NAT software, or through a proxy or something =
like=20
  that.</P>
  <P>Be aware that a hole in the firewall is nothing to be taken =
lightly. You=20
  have to make sure you don't give bad people access to the internal =
network; if=20
  you're a beginner, it's a lot harder to make software secure than you =
might=20
  imagine.</P>
  <P>Don't make your sysadmin mad at me. <TT>;-)</TT></P><!--  =
+++++++++++++++++++++++++  --><!-- =0A=
<faqentry>=0A=
=0A=
<q>When I have two interfaces, how do I=0A=
<func>bind()</func> to an interface by name (like=0A=
"<tt>eth0</tt>") instead of IP=0A=
address?</q>=0A=
=0A=
<a><p></p></a>=0A=
=0A=
</faqentry>=0A=
 --></DD></DL><!--  faq  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  conclusion  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!-- =0A=
<sect1 id=3D"conclusion">=0A=
<title>Disclaimer and Call for Help</title>=0A=
=0A=
<p>Well, that's the lot of it.  Hopefully at least some of the=0A=
information contained within this document has been remotely accurate=0A=
and I sincerely hope there aren't any glaring errors.  Well, sure, there=0A=
always are.</p>=0A=
=0A=
<p>So, let this be a warning to you!  I'm sorry if any inaccuracies=0A=
contained herein have caused you any grief, but you just can't hold me=0A=
accountable.  See, I don't stand behind a single word of this document,=0A=
legally speaking.  The whole thing could be completely and utterly=0A=
wrong!</p>=0A=
=0A=
<p>But it's probably not.  After all, I've spent many many hours=0A=
messing with this stuff, and implemented several TCP/IP network=0A=
utilities at work, have written multiplayer game engines, and so on.=0A=
But I'm not the sockets god; I'm just some guy.</p>=0A=
=0A=
<p>By the way, if anyone has any constructive (or destructive)=0A=
criticism about this document, please send mail to=0A=
<email>&beejmail;</email> and I'll try to make an effort to set the=0A=
record straight.</p>=0A=
=0A=
<p>In case you're wondering why I did this, well, I did it for the=0A=
money.  Ha!  No, really, I did it because a lot of people have asked me=0A=
socket-related questions and when I tell them I've been thinking about=0A=
putting together a socket page, they say, "Cool!"  Besides, I feel that=0A=
all this hard-earned knowledge is going to waste if I can't share it=0A=
with others.  The web just happens to be the perfect vehicle.  I=0A=
encourage others to provide similar information whenever=0A=
possible.</p>=0A=
=0A=
<p>Enough of this - back to coding!  <winky/></p>=0A=
 --><!--  </sect1>  --><!--  conclusion  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D manpages=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P><BR>
<HR>

<H2>8. <A name=3Dman>Man Pages</A></H2>
<P></P>
<P>In the Unix world, there are a lot of manuals. They have little =
sections that=20
describe individual functions that you have at your disposal.</P>
<P>Of course, <B><TT>manual</TT></B> would be too much of a thing to =
type. I=20
mean, no one in the Unix world, including myself, likes to type that =
much.=20
Indeed I could go on and on at great length about how much I prefer to =
be terse=20
but instead I shall be brief and not bore you with long-winded diatribes =
about=20
how utterly amazingly brief I prefer to be in virtually all =
circumstances in=20
their entirety.</P>
<P><I>[Applause]</I></P>
<P>Thank you. What I am getting at is that these pages are called "man =
pages" in=20
the Unix world, and I have included my own personal truncated variant =
here for=20
your reading enjoyment. The thing is, many of these functions are way =
more=20
general purpose than I'm letting on, but I'm only going to present the =
parts=20
that are relevant for Internet Sockets Programming.</P>
<P>But wait! That's not all that's wrong with my man pages:</P>
<UL>
  <LI>They are incomplete and only show the basics from the guide.=20
  <LI>There are many more man pages than this in the real world.=20
  <LI>They are different than the ones on your system.=20
  <LI>The header files might be different for certain functions on your =
system.=20
  <LI>The function parameters might be different for certain functions =
on your=20
  system. </LI></UL>
<P>If you want the real information, check your local Unix man pages by =
typing=20
<B><TT>man whatever</TT></B>, where "whatever" is something that you're=20
incredibly interested in, such as "<TT>accept</TT>". (I'm sure Microsoft =
Visual=20
Studio has something similar in their help section. But "man" is better =
because=20
it is one byte more concise than "help". Unix wins again!)</P>
<P>So, if these are so flawed, why even include them at all in the =
Guide? Well,=20
there are a few reasons, but the best are that (a) these versions are =
geared=20
specifically toward network programming and are easier to digest than =
the real=20
ones, and (b) these versions contain examples!</P>
<P>Oh! And speaking of the examples, I don't tend to put in all the =
error=20
checking because it really increases the length of the code. But you =
should=20
absolutely do error checking pretty much any time you make any of the =
system=20
calls unless you're totally 100% sure it's not going to fail, and you =
should=20
probably do it even then!</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D accept()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dacceptman><TT>accept()</TT></A></H2>
<P></P>
<P>Accept an incoming connection on a listening socket</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/types.h&gt;</TT><BR><TT>#include=20
  &lt;sys/socket.h&gt;</TT></P>
  <P><TT>int accept(int s, struct sockaddr *addr, socklen_t=20
  *addrlen);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>Once you've gone through the trouble of getting a=20
  <B><TT>SOCK_STREAM</TT></B> socket and setting it up for incoming =
connections=20
  with <TT>listen()</TT>, then you call <TT>accept()</TT> to actually =
get=20
  yourself a new socket descriptor to use for subsequent communication =
with the=20
  newly connected client.</P>
  <P>The old socket that you are using for listening is still there, and =
will be=20
  used for further <TT>accept()</TT> calls as they come in.</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"20%">
        <P><B><TT>s</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"78%">
        <P>The <TT>listen()</TT>ing socket descriptor.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft <p><B><TT>addr</TT></B>
        <P></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"78%">
        <P>This is filled in with the address of the site that's =
connecting to=20
        you.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft <p><B><TT>addrlen</TT></B>
        <P></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"78%">
        <P>This is filled in with the <TT>sizeof()</TT> the structure =
returned=20
        in the <B><TT>addr</TT></B> parameter. You can safely ignore it =
if you=20
        assume you're getting a <TT>struct sockaddr_in</TT> back, which =
you know=20
        you are, because that's the type you passed in for=20
        <B><TT>addr</TT></B>.</P></TD></TR></TBODY></TABLE></P>
  <P><TT>accept()</TT> will normally block, and you can use =
<TT>select()</TT> to=20
  peek on the listening socket descriptor ahead of time to see if it's =
"ready to=20
  read". If so, then there's a new connection waiting to be =
<TT>accept()</TT>ed!=20
  Yay! Alternatively, you could set the <B><TT>O_NONBLOCK</TT></B> flag =
on the=20
  listening socket using <TT>fcntl()</TT>, and then it will never block, =

  choosing instead to return <B><TT>-1</TT></B> with =
<B><TT>errno</TT></B> set=20
  to <B><TT>EWOULDBLOCK</TT></B>.</P>
  <P>The socket descriptor returned by <TT>accept()</TT> is a bona fide =
socket=20
  descriptor, open and connected to the remote host. You have to=20
  <TT>close()</TT> it when you're done with it.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P><TT>accept()</TT> returns the newly connected socket descriptor, or =

  <B><TT>-1</TT></B> on error, with <B><TT>errno</TT></B> set=20
  appropriately.</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s, s2;
struct sockaddr_in myaddr, remoteaddr;
socklen_t remoteaddr_len;

myaddr.sin_family =3D AF_INET;
myaddr.sin_port =3D htons(3490); // clients connect to this port
myaddr.sin_addr.s_addr =3D INADDR_ANY; // autoselect IP address

s =3D socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)myaddr, sizeof(myaddr));

listen(s, 10); // set s up to be a server (listening) socket

for(;;) {
    s2 =3D accept(s, &amp;remoteaddr, &amp;remoteaddr_len);

    // now you can send() and recv() with the
    // connected client via socket s2
}
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#socketman=
"><TT>socket()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#listenman=
"><TT>listen()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sockaddr_=
inman"><TT>struct=20
  sockaddr_in</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D bind=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dbindman><TT>bind()</TT></A></H2>
<P></P>
<P>Associate a socket with an IP address and port number</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/types.h&gt;</TT><BR><TT>#include=20
  &lt;sys/socket.h&gt;</TT></P>
  <P><TT>int bind(int sockfd, struct sockaddr *my_addr, socklen_t=20
  addrlen);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>When a remote machine wants to connect to your server program, it =
needs two=20
  pieces of information: the IP address and the port number. The =
<TT>bind()</TT>=20
  call allows you to do just that.</P>
  <P>First, you call <TT>socket()</TT> to get a socket descriptor, and =
then you=20
  load up a <TT>struct sockaddr_in</TT> with the IP address and port =
number=20
  information, and then you pass both of those into <TT>bind()</TT>, and =
the IP=20
  address and port are magically (using actual magic) bound to the =
socket!</P>
  <P>If you don't know your IP address, or you know you only have one IP =
address=20
  on the machine, or you don't care which of the machine's IP addresses =
is used,=20
  you can simply set the <TT>s_addr</TT> field in your <TT>struct=20
  sockaddr_in</TT> to <B><TT>INADDR_ANY</TT></B> and it will fill in the =
IP=20
  address for you.</P>
  <P>Lastly, the <B><TT>addrlen</TT></B> parameter should be set to=20
  <TT>sizeof(my_addr)</TT>.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns zero on success, or <B><TT>-1</TT></B> on error (and =
<TT>errno</TT>=20
  will be set accordingly.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>struct sockaddr_in myaddr;
int s;

myaddr.sin_family =3D AF_INET;
myaddr.sin_port =3D htons(3490);

// you can specify an IP address:
inet_aton("63.161.169.137", &amp;myaddr.sin_addr.s_addr);

// or you can let it automatically select one:
myaddr.sin_addr.s_addr =3D INADDR_ANY;

s =3D socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)myaddr, sizeof(myaddr));
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#socketman=
"><TT>socket()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sockaddr_=
inman"><TT>struct=20
  sockaddr_in</TT></A>, <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sockaddr_=
inman"><TT>struct=20
  in_addr</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D connect()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dconnectman><TT>connect()</TT></A></H2>
<P></P>
<P>Connect a socket to a server</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/types.h&gt;</TT><BR><TT>#include=20
  &lt;sys/socket.h&gt;</TT></P>
  <P><TT>int connect(int sockfd, const struct sockaddr=20
  =
*serv_addr,</TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&=
nbsp;&nbsp;&nbsp;&nbsp;socklen_t=20
  addrlen);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>Once you've built a socket descriptor with the <TT>socket()</TT> =
call, you=20
  can <TT>connect()</TT> that socket to a remote server using the =
well-named=20
  <TT>connect()</TT> system call. All you need to do is pass it the =
socket=20
  descriptor and the address of the server you're interested in getting =
to know=20
  better. (Oh, and the length of the address, which is commonly passed =
to=20
  functions like this.)</P>
  <P>If you haven't yet called <TT>bind()</TT> on the socket descriptor, =
it is=20
  automatically bound to your IP address and a random local port. This =
is=20
  usually just fine with you, since you really don't care what your =
local port=20
  is; you only care what the remote port is so you can put it in the=20
  <B><TT>serv_addr</TT></B> parameter. You <I>can</I> call =
<TT>bind()</TT> if=20
  you really want your client socket to be on a specific IP address and =
port,=20
  but this is pretty rare.</P>
  <P>Once the socket is <TT>connect()</TT>ed, you're free to =
<TT>send()</TT> and=20
  <TT>recv()</TT> data on it to your heart's content.</P>
  <P>Special note: if you <TT>connect()</TT> a =
<B><TT>SOCK_DGRAM</TT></B> UDP=20
  socket to a remote host, you can use <TT>send()</TT> and =
<TT>recv()</TT> as=20
  well as <TT>sendto()</TT> and <TT>recvfrom()</TT>. If you =
want.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns zero on success, or <B><TT>-1</TT></B> on error (and =
<TT>errno</TT>=20
  will be set accordingly.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s;
struct sockaddr_in serv_addr;

// pretend the server is at 63.161.169.137 listening on port 80:

myaddr.sin_family =3D AF_INET;
myaddr.sin_port =3D htons(80);
inet_aton("63.161.169.137", &amp;myaddr.sin_addr.s_addr);

s =3D socket(PF_INET, SOCK_STREAM, 0);
connect(s, (struct sockaddr*)myaddr, sizeof(myaddr));

// now we're ready to send() and recv()
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#socketman=
"><TT>socket()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#bindman">=
<TT>bind()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D close()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dcloseman><TT>close()</TT></A></H2>
<P></P>
<P>Close a socket descriptor</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;unistd.h&gt;</TT></P>
  <P><TT>int close(int s);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>After you've finished using the socket for whatever demented scheme =
you=20
  have concocted and you don't want to <TT>send()</TT> or =
<TT>recv()</TT> or,=20
  indeed, do <I>anything else</I> at all with the socket, you can=20
  <TT>close()</TT> it, and it'll be freed up, never to be used =
again.</P>
  <P>The remote side can tell if this happens one of two ways. One: if =
the=20
  remote side calls <TT>recv()</TT>, it will return <B><TT>0</TT></B>. =
Two: if=20
  the remote side calls <TT>send()</TT>, it'll recieve a signal=20
  <B><TT>SIGPIPE</TT></B> and send() will return <B><TT>-1</TT></B> and=20
  <B><TT>errno</TT></B> will be set to <B><TT>EPIPE</TT></B>.</P>
  <P><B>Windows users</B>: the function you need to use is called=20
  <TT>closesocket()</TT>, not <TT>close()</TT>. If you try to use=20
  <TT>close()</TT> on a socket descriptor, it's possible Windows will =
get=20
  angry... And you wouldn't like it when it's angry.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns zero on success, or <B><TT>-1</TT></B> on error (and =
<TT>errno</TT>=20
  will be set accordingly.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>s =3D socket(PF_INET, SOCK_DGRAM, 0);
.
.
.
// a whole lotta stuff...*BRRRONNNN!*
.
.
.
close(s);  // not much to it, really.
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#socketman=
"><TT>socket()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#shutdownm=
an"><TT>shutdown()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D gethostname()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dgethostnameman><TT>gethostname()</TT></A></H2>
<P></P>
<P>Returns the name of the system</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/unistd.h&gt;</TT></P>
  <P><TT>int gethostname(char *name, size_t len);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>Your system has a name. They all do. This is a slightly more Unixy =
thing=20
  than the rest of the networky stuff we've been talking about, but it =
still has=20
  its uses.</P>
  <P>For instance, you can get your host name, and then call=20
  <TT>gethostbyname()</TT> to find out your IP address.</P>
  <P>The parameter <B><TT>name</TT></B> should point to a buffer that =
will hold=20
  the host name, and <B><TT>len</TT></B> is the size of that buffer in =
bytes.=20
  <TT>gethostname()</TT> won't overwrite the end of the buffer (it might =
return=20
  an error, or it might just stop writing), and it will=20
  <B><TT>NUL</TT></B>-terminate the string if there's room for it in the =

  buffer.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns zero on success, or <B><TT>-1</TT></B> on error (and =
<TT>errno</TT>=20
  will be set accordingly.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>char hostname[128];

gethostname(hostname, sizeof(hostname));
printf("My hostname: %s\n", hostname);
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#gethostby=
nameman"><TT>gethostbyname()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D gethostbyname(), gethostbyaddr()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dgethostbynameman><TT>gethostbyname()</TT>,=20
<TT>gethostbyaddr()</TT></A></H2>
<P></P>
<P>Get an IP address for a hostname, or vice-versa</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/socket.h&gt;</TT><BR><TT>#include=20
  &lt;netdb.h&gt;</TT></P>
  <P><TT>struct hostent *gethostbyname(const char =
*name);</TT><BR><TT>struct=20
  hostent *gethostbyaddr(const char *addr, int len, int =
type);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>These functions map back and forth between host names and IP =
addresses.=20
  After all, you want an IP address to pass to <TT>connect()</TT>, =
right? But no=20
  one wants to remember an IP address. So you let your users type in =
things like=20
  "www.yahoo.com" instead of "66.94.230.35".</P>
  <P><TT>gethostbyname()</TT> takes a string like "www.yahoo.com", and =
returns a=20
  <TT>struct hostent</TT> which contains tons of information, including =
the IP=20
  address. (Other information is the official host name, a list of =
aliases, the=20
  address type, the length of the addresses, and the list of =
addresses--it's a=20
  general-purpose structure that's pretty easy to use for our specific =
purposes=20
  once you see how.)</P>
  <P><TT>gethostbyaddr()</TT> takes a <TT>struct in_addr</TT> and brings =
you up=20
  a corresponding host name (if there is one), so it's sort of the =
reverse of=20
  <TT>gethostbyname()</TT>. As for parameters, even though =
<B><TT>addr</TT></B>=20
  is a <TT>char*</TT>, you actually want to pass in a pointer to a =
<TT>struct=20
  in_addr</TT>. <B><TT>len</TT></B> should be <TT>sizeof(struct =
in_addr)</TT>,=20
  and <B><TT>type</TT></B> should be <B><TT>AF_INET</TT></B>.</P>
  <P>So what is this <TT>struct hostent</TT> that gets returned? It has =
a number=20
  of fields that contain information about the host in question.</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>char *h_name</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>The real canonical host name.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>char **h_aliases</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>A list of aliases that can be accessed with arrays--the last =
element=20
        is <B><TT>NULL</TT></B></P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>int h_addrtype</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>The result's address type, which really should be=20
        <B><TT>AF_INET</TT></B> for our purposes..</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>int length</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>The length of the addresses in bytes, which is 4 for IP =
(version 4)=20
        addresses.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>char **h_addr_list</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>A list of IP addresses for this host. Although this is a=20
        <TT>char**</TT>, it's really an array of <TT>struct =
in_addr*</TT>s in=20
        disguise. The last array element is =
<B><TT>NULL</TT></B>.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>h_addr</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>A commonly defined alias for <B><TT>h_addr_list[0]</TT></B>. =
If you=20
        just want any old IP address for this host (yeah, they can have =
more=20
        than one) just use this =
field.</P></TD></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns a pointer to a resultant <TT>struct hostent</TT> or =
success, or=20
  <B><TT>NULL</TT></B> on error.</P>
  <P>Instead of the normal <TT>perror()</TT> and all that stuff you'd =
normally=20
  use for error reporting, these functions have parallel results in the =
variable=20
  <B><TT>h_errno</TT></B>, which can be printed using the functions=20
  <TT>herror()</TT> or <TT>hstrerror()</TT>. These work just like the =
classic=20
  <B><TT>errno</TT></B>, <TT>perror()</TT>, and <TT>strerror()</TT> =
functions=20
  you're used to.</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int i;
struct hostent *he;
struct in_addr **addr_list;
struct in_addr addr;

// get the addresses of www.yahoo.com:

he =3D gethostbyname("www.yahoo.com");
if (he =3D=3D NULL) { // do some error checking
    herror("gethostbyname"); // herror(), NOT perror()
    exit(1);
}

// print information about this host:
printf("Official name is: %s\n", he-&gt;h_name);
printf("IP address: %s\n", inet_ntoa(*(struct in_addr*)he-&gt;h_addr));
printf("All addresses: ");
addr_list =3D (struct in_addr **)he-&gt;h_addr_list;
for(i =3D 0; addr_list[i] !=3D NULL; i++) {
    printf("%s ", inet_ntoa(*addr_list[i]));
}
printf("\n");

// get the host name of 66.94.230.32:

inet_aton("66.94.230.32", &amp;addr);
he =3D gethostbyaddr(&amp;addr, sizeof(addr), AF_INET);

printf("Host name: %s\n", he-&gt;h_name);
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#gethostna=
meman"><TT>gethostname()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#errnoman"=
><B><TT>errno</TT></B></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#perrorman=
"><TT>perror()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#perrorman=
"><TT>strerror()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sockaddr_=
inman"><TT>struct=20
  in_addr</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D getpeername()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dgetpeernameman><TT>getpeername()</TT></A></H2>
<P></P>
<P>Return address info about the remote side of the connection</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/socket.h&gt;</TT></P>
  <P><TT>int getpeername(int s, struct sockaddr *addr, socklen_t=20
  *len);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>Once you have either <TT>accept()</TT>ed a remote connection, or=20
  <TT>connect()</TT>ed to a server, you now have what is known as a =
<I>peer</I>.=20
  Your peer is simply the computer you're connected to, identified by an =
IP=20
  address and a port. So...</P>
  <P><TT>getpeername()</TT> simply returns a <TT>struct sockaddr_in</TT> =
filled=20
  with information about the machine you're connected to.</P>
  <P>Why is it called a "name"? Well, there are a lot of different kinds =
of=20
  sockets, not just Internet Sockets like we're using in this guide, and =
so=20
  "name" was a nice generic term that covered all cases. In our case, =
though,=20
  the peer's "name" is it's IP address and port.</P>
  <P>Although the function returns the size of the resultant address in=20
  <B><TT>len</TT></B>, you must preload <B><TT>len</TT></B> with the =
size of=20
  <B><TT>addr</TT></B>.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns zero on success, or <B><TT>-1</TT></B> on error (and =
<TT>errno</TT>=20
  will be set accordingly.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s;
struct sockaddr_in server, addr;
socklen_t len;

// make a socket
s =3D socket(PF_INET, SOCK_STREAM, 0);

// connect to a server
server.sin_family =3D AF_INET;
inet_aton("63.161.169.137", &amp;server.sin_addr);
server.sin_port =3D htons(80);

connect(s, (struct sockaddr*)&amp;server, sizeof(server));

// get the peer name
// we know we just connected to 63.161.169.137:80, so this should print:
//    Peer IP address: 63.161.169.137
//    Peer port      : 80

len =3D sizeof(addr);
getpeername(s, (struct sockaddr*)&amp;addr, &amp;len);
printf("Peer IP address: %s\n", inet_ntoa(addr.sin_addr));
printf("Peer port      : %d\n", ntohs(addr.sin_port));
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#gethostna=
meman"><TT>gethostname()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#gethostby=
nameman"><TT>gethostbyname()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#gethostby=
nameman"><TT>gethostbyaddr()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D errno=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Derrnoman><B><TT>errno</TT></B></A></H2>
<P></P>
<P>Holds the error code for the last system call</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;errno.h&gt;</TT></P>
  <P><TT>int errno;</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>This is the variable that holds error information for a lot of =
system=20
  calls. If you'll recall, things like <TT>socket()</TT> and =
<TT>listen()</TT>=20
  return <B><TT>-1</TT></B> on error, and they set the exact value of=20
  <B><TT>errno</TT></B> to let you know specifically which error =
occurred.</P>
  <P>The header file <I><TT>errno.h</TT></I> lists a bunch of constant =
symbolic=20
  names for errors, such as <B><TT>EADDRINUSE</TT></B>, =
<B><TT>EPIPE</TT></B>,=20
  <B><TT>ECONNREFUSED</TT></B>, etc. Your local man pages will tell you =
what=20
  codes can be returned as an error, and you can use these at run time =
to handle=20
  different errors in different ways.</P>
  <P>Or, more commonly, you can call <TT>perror()</TT> or =
<TT>strerror()</TT> to=20
  get a human-readable version of the error.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>The value of the variable is the latest error to have transpired, =
which=20
  might be the code for "success" if the last action =
succeeded.</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>s =3D socket(PF_INET, SOCK_STREAM, 0);
if (s =3D=3D -1) {
    perror("socket"); // or use strerror()
}

tryagain:
if (select(n, &amp;readfds, NULL, NULL) =3D=3D -1) {
    // an error has occurred!!

    // if we were only interrupted, just restart the select() call:
    if (errno =3D=3D EINTR) goto tryagain;  // AAAA!  goto!!!

    // otherwise it's a more serious error:
    perror("select");
    exit(1);
}
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#perrorman=
"><TT>perror()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#perrorman=
"><TT>strerror()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D fcntl()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dfcntlman><TT>fcntl()</TT></A></H2>
<P></P>
<P>Control socket descriptors</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/unistd.h&gt;</TT><BR><TT>#include=20
  &lt;sys/fcntl.h&gt;</TT></P>
  <P><TT>int fcntl(int s, int cmd, long arg);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>This function is typically used to do file locking and other =
file-oriented=20
  stuff, but it also has a couple socket-related functions that you =
might see or=20
  use from time to time.</P>
  <P>Parameter <B><TT>s</TT></B> is the socket descriptor you wish to =
operate=20
  on, <B><TT>cmd</TT></B> should be set to <B><TT>F_SETFL</TT></B>, and=20
  <B><TT>arg</TT></B> can be one of the following commands. (Like I =
said,=20
  there's more to <TT>fcntl()</TT> than I'm letting on here, but I'm =
trying to=20
  stay socket-oriented.)</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"20%">
        <P><B><TT>O_NONBLOCK</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"73%">
        <P>Set the socket to be non-blocking. See the section on <A=20
        =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#blocking"=
>blocking</A>=20
        for more details.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"20%">
        <P><B><TT>O_ASYNC</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"73%">
        <P>Set the socket to do asynchronous I/O. When data is ready to =
be=20
        <TT>recv()</TT>'d on the socket, the signal =
<B><TT>SIGIO</TT></B> will=20
        be raised. This is rare to see, and beyond the scope of the =
guide. And I=20
        think it's only available on certain=20
  systems.</P></TD></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns zero on success, or <B><TT>-1</TT></B> on error (and =
<TT>errno</TT>=20
  will be set accordingly.)</P>
  <P>Different uses of the <TT>fcntl()</TT> actually have different =
return=20
  values, but I haven't covered them here because they're not =
socket-related.=20
  See your local <TT>fcntl()</TT> man page for more =
information.</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s =3D socket(PF_INET, SOCK_STREAM, =
0);

fcntl(s, F_SETFL, O_NONBLOCK);  // set to non-blocking
fcntl(s, F_SETFL, O_ASYNC);     // set to asynchronous I/O
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#blocking"=
>Blocking</A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendman">=
<TT>send()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D htons, htonl, ntohs, ntohl=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dhtonsman><TT>htons()</TT>, <TT>htonl()</TT>, =
<TT>ntohs()</TT>,=20
<TT>ntohl()</TT></A></H2>
<P></P>
<P>Convert multi-byte integer types from host byte order to network byte =

order</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;netinet/in.h&gt;</TT></P>
  <P><TT>uint32_t htonl(uint32_t hostlong);</TT><BR><TT>uint16_t =
htons(uint16_t=20
  hostshort);</TT><BR><TT>uint32_t ntohl(uint32_t =
netlong);</TT><BR><TT>uint16_t=20
  ntohs(uint16_t netshort);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>Just to make you really unhappy, different computers use different =
byte=20
  orderings internally for their multibyte integers (i.e. any interger =
that's=20
  larger than a <TT>char</TT>.) The upshot of this is that if you=20
  <TT>send()</TT> a two-byte <TT>short int</TT> from an Intel box to a =
Mac=20
  (before they became Intel boxes, too, I mean), what one computer =
thinks is the=20
  number <B><TT>1</TT></B>, the other will think is the number=20
  <B><TT>256</TT></B>, and vice-versa.</P>
  <P>The way to get around this problem is for everyone to put aside =
their=20
  differences and agree that Motorola and IBM had it right, and Intel =
did it the=20
  weird way, and so we all convert our byte orderings to "big-endian" =
before=20
  sending them out. Since Intel is a "little-endian" machine, it's far =
more=20
  politically correct to call our preferred byte ordering "Network Byte =
Order".=20
  So these functions convert from your native byte order to network byte =
order=20
  and back again.</P>
  <P>(This means on Intel these functions swap all the bytes around, and =
on=20
  PowerPC they do nothing because the bytes are already in Network Byte =
Order.=20
  But you should always use them in your code anyway, since someone =
might want=20
  to build it on an Intel machine and still have things work =
properly.)</P>
  <P>Note that the types involved are 32-bit (4 byte, probably =
<TT>int</TT>) and=20
  16-bit (2 byte, very likely <TT>short</TT>) numbers. 64-bit machines =
might=20
  have a <TT>htonll()</TT> for 64-bit ints, but I've not seen it. You'll =
just=20
  have to write your own.</P>
  <P>Anyway, the way these functions work is that you first decide if =
you're=20
  converting <I>from</I> host (your machine's) byte order or from =
network byte=20
  order. If "host", the the first letter of the function you're going to =
call is=20
  "h". Otherwise it's "n" for "network". The middle of the function name =
is=20
  always "to" because you're converting from one "to" another, and the=20
  penultimate letter shows what you're converting <I>to</I>. The last =
letter is=20
  the size of the data, "s" for short, or "l" for long. Thus:</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"15%">
        <P><TT>htons()</TT></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"78%">
        <P><I>h</I>ost <I>to</I> <I>n</I>etwork =
<I>s</I>hort</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"15%">
        <P><TT>htonl()</TT></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"78%">
        <P><I>h</I>ost <I>to</I> <I>n</I>etwork =
<I>l</I>ong</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"15%">
        <P><TT>ntohs()</TT></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"78%">
        <P><I>n</I>etwork <I>to</I> <I>h</I>ost =
<I>s</I>hort</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"15%">
        <P><TT>ntohl()</TT></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"78%">
        <P><I>n</I>etwork <I>to</I> <I>h</I>ost=20
  <I>l</I>ong</P></TD></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Each function returns the converted value.</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>uint32_t some_long =3D 10;
uint16_t some_short =3D 20;

uint32_t network_byte_order;

// convert and send
network_byte_order =3D htonl(some_long);
send(s, &amp;network_byte_order, sizeof(uint32_t), 0);

some_short =3D=3D ntohs(htons(some_short)); // this expression is true
</PRE></TR></TBODY></TABLE></P></DD></DL><!-- =0A=
<seealso>=0A=
</seealso>=0A=
 --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D inet_ntoa() etc=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dinet_ntoaman><TT>inet_ntoa()</TT>, =
<TT>inet_aton()</TT></A></H2>
<P></P>
<P>Convert IP addresses from a dots-and-number string to a <TT>struct=20
in_addr</TT> and back</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/socket.h&gt;</TT><BR><TT>#include=20
  &lt;netinet/in.h&gt;</TT><BR><TT>#include &lt;arpa/inet.h&gt;</TT></P>
  <P><TT>char *inet_ntoa(struct in_addr in);</TT><BR><TT>int =
inet_aton(const=20
  char *cp, struct in_addr *inp);</TT><BR><TT>in_addr_t inet_addr(const =
char=20
  *cp);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>All of these functions convert from a <TT>struct in_addr</TT> (part =
of your=20
  <TT>struct sockaddr_in</TT>, most likely) to a string in =
dots-and-numbers=20
  format (e.g. "192.168.5.10") and vice-versa. If you have an IP address =
passed=20
  on the command line or something, this is the easiest way to get a =
<TT>struct=20
  in_addr</TT> to <TT>connect()</TT> to, or whatever. If you need more =
power,=20
  try some of the DNS functions like <TT>gethostbyname()</TT> or attempt =
a=20
  coup-de-tat in your local country.</P>
  <P>The function <TT>inet_ntoa()</TT> converts a network address in a=20
  <TT>struct in_addr</TT> to a dots-and-numbers format string. The "n" =
in "ntoa"=20
  stands for network, and the "a" stands for ASCII for historical =
reasons (so=20
  it's "Network To ASCII"--the "toa" suffix has an analogous friend in =
the C=20
  library called <TT>atoi()</TT> which converts an ASCII string to an=20
  integer.)</P>
  <P>The function <TT>inet_aton()</TT> is the opposite, converting from =
a=20
  dots-and-numbers string into a <TT>in_addr_t</TT> (which is the type =
of the=20
  field <TT>s_addr</TT> in your <TT>struct in_addr</TT>.)</P>
  <P>Finally, the function <TT>inet_addr()</TT> is an older function =
that does=20
  basically the same thing as <TT>inet_aton()</TT>. It's theoretically=20
  deprecated, but you'll see it alot and the police won't come get you =
if you=20
  use it.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P><TT>inet_aton()</TT> returns non-zero if the address is a valid =
one, and it=20
  returns zero if the address is invalid.</P>
  <P><TT>inet_ntoa()</TT> returns the dots-and-numbers string in a =
static buffer=20
  that is overwritten with each call to the function.</P>
  <P><TT>inet_addr()</TT> returns the address as an <TT>in_addr_t</TT>, =
or=20
  <B><TT>-1</TT></B> if there's an error. (That is the same result as if =
you=20
  tried to convert the string "255.255.255.255", which is a valid IP =
address.=20
  This is why <TT>inet_aton()</TT> is better.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>struct sockaddr_in antelope;
char *some_addr;

inet_aton("10.0.0.1", &amp;antelope.sin_addr); // store IP in antelope

some_addr =3D inet_ntoa(antelope.sin_addr); // return the IP
printf("%s\n", some_addr); // prints "10.0.0.1"

// and this call is the same as the inet_aton() call, above:
antelope.sin_addr.s_addr =3D inet_addr("10.0.0.1");
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#gethostby=
nameman"><TT>gethostbyname()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#gethostby=
nameman"><TT>gethostbyaddr()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D listen()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dlistenman><TT>listen()</TT></A></H2>
<P></P>
<P>Tell a socket to listen for incoming connections</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/socket.h&gt;</TT></P>
  <P><TT>int listen(int s, int backlog);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>You can take your socket descriptor (made with the =
<TT>socket()</TT> system=20
  call) and tell it to listen for incoming connections. This is what=20
  differentiates the servers from the clients, guys.</P>
  <P>The <B><TT>backlog</TT></B> parameter can mean a couple different =
things=20
  depending on the system you on, but loosely it is how many pending =
connections=20
  you can have before the kernel starts rejecting new ones. So as the =
new=20
  connections come in, you should be quick to <TT>accept()</TT> them so =
that the=20
  backlog doesn't fill. Try setting it to 10 or so, and if your clients =
start=20
  getting "Connection refused" under heavy load, set it higher.</P>
  <P>Before calling <TT>listen()</TT>, your server should call =
<TT>bind()</TT>=20
  to attach itself to a specific port number. That port number (on the =
server's=20
  IP address) will be the one that clients connect to.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns zero on success, or <B><TT>-1</TT></B> on error (and =
<TT>errno</TT>=20
  will be set accordingly.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s;
struct sockaddr_in myaddr;

myaddr.sin_family =3D AF_INET;
myaddr.sin_port =3D htons(3490); // clients connect to this port
myaddr.sin_addr.s_addr =3D INADDR_ANY; // autoselect IP address

s =3D socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)myaddr, sizeof(myaddr));

listen(s, 10); // set s up to be a server (listening) socket

// then have an accept() loop down here somewhere
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#acceptman=
"><TT>accept()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#bindman">=
<TT>bind()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#socketman=
"><TT>socket()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D perror()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dperrorman><TT>perror()</TT>, <TT>strerror()</TT></A></H2>
<P></P>
<P>Print an error as a human-readable string</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;stdio.h&gt;</TT></P>
  <P><TT>void perror(const char *s);</TT></P>
  <P><TT>#include &lt;string.h&gt;</TT></P>
  <P><TT>char *strerror(int errnum);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>Since so many functions return <B><TT>-1</TT></B> on error and set =
the=20
  value of the variable <B><TT>errno</TT></B> to be some number, it =
would sure=20
  be nice if you could easily print that in a form that made sense to =
you.</P>
  <P>Mercifully, <TT>perror()</TT> does that. If you want more =
description to be=20
  printed before the error, you can point the parameter =
<B><TT>s</TT></B> to it=20
  (or you can leave <B><TT>s</TT></B> as <B><TT>NULL</TT></B> and =
nothing=20
  additional will be printed.)</P>
  <P>In a nutshell, this function takes <B><TT>errno</TT></B> values, =
like=20
  <B><TT>ECONNRESET</TT></B>, and prints them nicely, like "Connection =
reset by=20
  peer."</P>
  <P>The function <TT>strerror()</TT> is very similar to =
<TT>perror()</TT>,=20
  except it returns a pointer to the error message string for a given =
value (you=20
  usually pass in the variable <B><TT>errno</TT></B>.)</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P><TT>strerror()</TT> returns a pointer to the error message=20
string.</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s;

s =3D socket(PF_INET, SOCK_STREAM, 0);

if (s =3D=3D -1) { // some error has occurred
    // prints "socket error: " + the error message:
    perror("socket error");
}

// similarly:
if (listen(s, 10) =3D=3D -1) {
    // this prints "an error: " + the error message from errno:
    printf("an error: %s\n", strerror(errno));
}
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#errnoman"=
><B><TT>errno</TT></B></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D poll=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dpollman><TT>poll()</TT></A></H2>
<P></P>
<P>Test for events on multiple sockets simultaneously</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/poll.h&gt;</TT></P>
  <P><TT>int poll(struct pollfd *ufds, unsigned int nfds, int=20
  timeout);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>This function is very similar to <TT>select()</TT> in that they =
both watch=20
  sets of file descriptors for events, such as incoming data ready to=20
  <TT>recv()</TT>, socket ready to <TT>send()</TT> data to, out-of-band =
data=20
  ready to <TT>recv()</TT>, errors, etc.</P>
  <P>The basic idea is that you pass an array of <B><TT>nfds</TT></B> =
<TT>struct=20
  pollfd</TT>s in <B><TT>ufds</TT></B>, along with a timeout in =
milliseconds=20
  (1000 milliseconds in a second.) The <B><TT>timeout</TT></B> can be =
negative=20
  if you want to wait forever. If no event happen on any of the socket=20
  descriptors by the timeout, <TT>poll()</TT> will return.</P>
  <P>Each element in the array of <TT>struct pollfd</TT>s represents one =
socket=20
  descriptor, and contains the following fields:</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>struct pollfd {
    int fd;         // the socket descriptor
    short events;   // bitmap of events we're interested in
    short revents;  // when poll() returns, bitmap of events that =
occurred
};
</PRE></TR></TBODY></TABLE></P>
  <P>Before calling <TT>poll()</TT>, load <B><TT>fd</TT></B> with the =
socket=20
  descriptor (if you set <B><TT>fd</TT></B> to a negative number, this=20
  <TT>struct pollfd</TT> is ignored and its <B><TT>revents</TT></B> =
field is set=20
  to zero) and then construct the <B><TT>events</TT></B> field by =
bitwise-ORing=20
  the following macros:</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"25%">
        <P><B><TT>POLLIN</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"73%">
        <P>Alert me when data is ready to <TT>recv()</TT> on this=20
    socket.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"25%">
        <P><B><TT>POLLOUT</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"73%">
        <P>Alert me when I can <TT>send()</TT> data to this socket =
without=20
        blocking.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"25%">
        <P><B><TT>POLLPRI</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"73%">
        <P>Alert me when out-of-band data is ready to <TT>recv()</TT> on =
this=20
        socket.</P></TD></TR></TBODY></TABLE></P>
  <P>Once the <TT>poll()</TT> call returns, the <B><TT>revents</TT></B> =
field=20
  will be constructed as a bitwise-OR of the above fields, telling you =
which=20
  descriptors actually have had that event occur. Additionally, these =
other=20
  fields might be present:</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"25%">
        <P><B><TT>POLLERR</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"73%">
        <P>An error has occurred on this socket.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"25%">
        <P><B><TT>POLLHUP</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"73%">
        <P>The remote side of the connection hung up.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"25%">
        <P><B><TT>POLLNVAL</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"73%">
        <P>Something was wrong with the socket descriptor=20
        <B><TT>fd</TT></B>--maybe it's=20
  uninitialized?</P></TD></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns the number of elements in the <B><TT>ufds</TT></B> array =
that have=20
  had event occur on them; this can be zero if the timeout occurred. =
Also=20
  returns <B><TT>-1</TT></B> on error (and <TT>errno</TT> will be set=20
  accordingly.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s1, s2;
int rv;
char buf1[256], buf2[256];
struct pollfd ufds[2];

s1 =3D socket(PF_INET, SOCK_STREAM, 0);
s2 =3D socket(PF_INET, SOCK_STREAM, 0);

// pretend we've connected both to a server at this point
//connect(s1, ...)...
//connect(s2, ...)...

// set up the array of file descriptors.
//
// in this example, we want to know when there's normal or out-of-band
// data ready to be recv()'d...

ufds[0].fd =3D s1;
ufds[0].events =3D POLLIN | POLLPRI; // check for normal or out-of-band

ufds[1] =3D s2;
ufds[1].events =3D POLLIN; // check for just normal data

// wait for events on the sockets, 3.5 second timeout
rv =3D poll(ufds, 2, 3500);

if (rv =3D=3D -1) {
    perror("poll"); // error occurred in poll()
} else if (rv =3D=3D 0) {
    printf("Timeout occurred!  No data after 3.5 seconds.\n");
} else {
    // check for events on s1:
    if (ufds[0].revents &amp; POLLIN) {
        recv(s1, buf1, sizeof(buf1), 0); // receive normal data
    }
    if (ufds[0].revents &amp; POLLPRI) {
        recv(s1, buf1, sizeof(buf1), MSG_OOB); // out-of-band data
    }

    // check for events on s2:
    if (ufds[1].revents &amp; POLLIN) {
        recv(s1, buf2, sizeof(buf2), 0);
    }
}
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#selectman=
"><TT>select()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D recv(), recvfrom()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Drecvman><TT>recv()</TT>, <TT>recvfrom()</TT></A></H2>
<P></P>
<P>Recieve data on a socket</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/types.h&gt;</TT><BR><TT>#include=20
  &lt;sys/socket.h&gt;</TT></P>
  <P><TT>ssize_t recv(int s, void *buf, size_t len, int=20
  flags);</TT><BR><TT>ssize_t recvfrom(int s, void *buf, size_t len, int =

  =
flags,</TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct=20
  sockaddr *from, socklen_t *fromlen);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>Once you have a socket up and connected, you can read incoming data =
from=20
  the remote side using the <TT>recv()</TT> (for TCP =
<B><TT>SOCK_STREAM</TT></B>=20
  sockets) and <TT>recvfrom()</TT> (for UDP <B><TT>SOCK_DGRAM</TT></B>=20
  sockets).</P>
  <P>Both functions take the socket descriptor <B><TT>s</TT></B>, a =
pointer to=20
  the buffer <B><TT>buf</TT></B>, the size (in bytes) of the buffer=20
  <B><TT>len</TT></B>, and a set of <B><TT>flags</TT></B> that control =
how the=20
  functions work.</P>
  <P>Additionally, the <TT>recvfrom()</TT> takes a <TT>struct =
sockaddr*</TT>,=20
  <B><TT>from</TT></B> that will tell you where the data came from, and =
will=20
  fill in <B><TT>fromlen</TT></B> with the size of <TT>struct =
sockaddr</TT>.=20
  (You must also initialize <B><TT>fromlen</TT></B> to be the size of=20
  <B><TT>from</TT></B> or <TT>struct sockaddr</TT>.)</P>
  <P>So what wonderous flags can you pass into this function? Here are =
some of=20
  them, but you should check your local man pages for more information =
and what=20
  is actually supported on your system. You bitwise-or these together, =
or just=20
  set <B><TT>flags</TT></B> to <B><TT>0</TT></B> if you want it to be a =
regular=20
  vanilla <TT>recv()</TT>.</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>MSG_OOB</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>Recieve Out of Band data. This is how to get data that has =
been sent=20
        to you with the <B><TT>MSG_OOB</TT></B> flag in <TT>send()</TT>. =
As the=20
        recieving side, you will have had signal <B><TT>SIGURG</TT></B> =
raised=20
        telling you there is urgent data. In your handler for that =
signal, you=20
        could call <TT>recv()</TT> with this <B><TT>MSG_OOB</TT></B>=20
    flag.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>MSG_PEEK</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>If you want to call <TT>recv()</TT> "just for pretend", you =
can call=20
        it with this flag. This will tell you what's waiting in the =
buffer for=20
        when you call <TT>recv()</TT> "for real" (i.e. <I>without</I> =
the=20
        <B><TT>MSG_PEEK</TT></B> flag. It's like a sneak preview into =
the next=20
        <TT>recv()</TT> call.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>MSG_WAITALL</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>Tell <TT>recv()</TT> to not return until all the data you =
specified=20
        in the <B><TT>len</TT></B> parameter. It will ignore your wishes =
in=20
        extreme circumstances, however, like if a signal interrupts the =
call or=20
        if some error occurs or if the remote side closes the =
connection, etc.=20
        Don't be mad with it.</P></TD></TR></TBODY></TABLE></P>
  <P>When you call <TT>recv()</TT>, it will block until there is some =
data to=20
  read. If you want to not block, set the socket to non-blocking or =
check with=20
  <TT>select()</TT> or <TT>poll()</TT> to see if there is incoming data =
before=20
  calling <TT>recv()</TT> or <TT>recvfrom()</TT>.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns the number of bytes actually recieved (which might be less =
than you=20
  requested in the <B><TT>len</TT></B> paramter), or <B><TT>-1</TT></B> =
on error=20
  (and <TT>errno</TT> will be set accordingly.)</P>
  <P>If the remote side has closed the connection, <TT>recv()</TT> will =
return=20
  <B><TT>0</TT></B>. This is the normal method for determining if the =
remote=20
  side has closed the connection. Normality is good, =
rebel!</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s1, s2;
int byte_count, fromlen;
struct sockaddr_in addr;
char buf[512];

// show example with a TCP stream socket first
s1 =3D socket(PF_INET, SOCK_STREAM, 0);

// info about the server
addr.sin_family =3D AF_INET;
addr.sin_port =3D htons(3490);
inet_aton("10.9.8.7", &amp;addr.sin_addr);

connect(s1, &amp;addr, sizeof(addr)); // connect to server

// all right!  now that we're connected, we can recieve some data!
byte_count =3D recv(s1, buf, sizeof(buf), 0);
printf("recv()'d %d bytes of data in buf\n", byte_count);

// now demo for UDP datagram sockets:
s2 =3D socket(PF_INET, SOCK_DGRAM, 0);

fromlen =3D sizeof(addr);
byte_count =3D recvfrom(s2, buf, sizeof(buf), 0, &amp;addr, =
&amp;fromlen);
printf("recv()'d %d bytes of data in buf\n", byte_count);
printf("from IP address %s\n", inet_ntoa(addr.sin_addr));
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendman">=
<TT>send()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendman">=
<TT>sendto()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#selectman=
"><TT>select()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#pollman">=
<TT>poll()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#blocking"=
>Blocking</A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D select()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dselectman><TT>select()</TT></A></H2>
<P></P>
<P>Check if sockets descriptors are ready to read/write</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/select.h&gt;</TT></P>
  <P><TT>int select(int n, fd_set *readfds, fd_set=20
  =
*writefds,</TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
bsp;&nbsp;&nbsp;fd_set=20
  *exceptfds, struct timeval *timeout);</TT><BR><TT>FD_SET(int fd, =
fd_set=20
  *set);</TT><BR><TT>FD_CLR(int fd, fd_set =
*set);</TT><BR><TT>FD_ISSET(int fd,=20
  fd_set *set);</TT><BR><TT>FD_ZERO(fd_set *set);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>The <TT>select()</TT> function gives you a way to simultaneously =
check=20
  multiple sockets to see if they have data waiting to be =
<TT>recv()</TT>d, or=20
  if you can <TT>send()</TT> data to them without blocking, or if some =
exception=20
  has occurred.</P>
  <P>You populate your sets of socket descriptors using the macros, like =

  <TT>FD_SET()</TT>, above. Once you have the set, you pass it into the =
function=20
  as one of the following parameters: <B><TT>readfds</TT></B> if you =
want to=20
  know when any of the sockets in the set is ready to <TT>recv()</TT> =
data,=20
  <B><TT>writefds</TT></B> if any of the sockets is ready to =
<TT>send()</TT>=20
  data to, and/or <B><TT>exceptfds</TT></B> if you need to know when an=20
  exception (error) occurs on any of the sockets. Any or all of these =
parameters=20
  can be <B><TT>NULL</TT></B> if you're not interested in those types of =
events.=20
  After <TT>select()</TT> returns, the values in the sets will be =
changed to=20
  show which are ready for reading or writing, and which have =
exceptions.</P>
  <P>The first parameter, <B><TT>n</TT></B> is the highest-numbered =
socket=20
  descriptor (they're just <TT>int</TT>s, remember?) plus one.</P>
  <P>Lastly, the <TT>struct timeval</TT>, <B><TT>timeout</TT></B>, at =
the=20
  end--this lets you tell <TT>select()</TT> how long to check these sets =
for.=20
  It'll return after the timeout, or when an event occurs, whichever is =
first.=20
  The <TT>struct timeval</TT> has two fields: <B><TT>tv_sec</TT></B> is =
the=20
  number of seconds, to which is added <B><TT>tv_usec</TT></B>, the =
number of=20
  microseconds (1,000,000 microseconds in a second.)</P>
  <P>The helper macros do the following:</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"50%">
        <P><TT>FD_SET(int fd, fd_set *set);</TT></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"48%">
        <P>Add <B><TT>fd</TT></B> to the =
<B><TT>set</TT></B>.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"50%">
        <P><TT>FD_CLR(int fd, fd_set *set);</TT></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"48%">
        <P>Remove <B><TT>fd</TT></B> from the =
<B><TT>set</TT></B>.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"50%">
        <P><TT>FD_ISSET(int fd, fd_set *set);</TT></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"48%">
        <P>Return true if <B><TT>fd</TT></B> is in the=20
      <B><TT>set</TT></B>.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"50%">
        <P><TT>FD_ZERO(fd_set *set);</TT></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"48%">
        <P>Clear all entries from the=20
  <B><TT>set</TT></B>.</P></TD></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns the number of descriptors in the set on success, =
<B><TT>0</TT></B>=20
  if the timeout was reached, or <B><TT>-1</TT></B> on error (and =
<TT>errno</TT>=20
  will be set accordingly.) Also, the sets are modified to show which =
sockets=20
  are ready.</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s1, s2, n;
fd_set readfds;
struct timeval tv;
char buf1[256], buf2[256];

s1 =3D socket(PF_INET, SOCK_STREAM, 0);
s2 =3D socket(PF_INET, SOCK_STREAM, 0);

// pretend we've connected both to a server at this point
//connect(s1, ...)...
//connect(s2, ...)...

// clear the set ahead of time
FD_ZERO(&amp;readfds);

// add our descriptors to the set
FD_SET(s1, &amp;readfds);
FD_SET(s2, &amp;readfds);

// since we got s2 second, it's the "greater", so we use that for
// the n param in select()
n =3D s2 + 1;

// wait until either socket has data ready to be recv()d (timeout 10.5 =
secs)
tv.tv_sec =3D 10;
tv.tv_usec =3D 500000;
rv =3D select(n, &amp;readfds, NULL, NULL, &amp;tv);

if (rv =3D=3D -1) {
    perror("select"); // error occurred in select()
} else if (rv =3D=3D 0) {
    printf("Timeout occurred!  No data after 10.5 seconds.\n");
} else {
    // one or both of the descriptors have data
    if (FD_ISSET(s1, &amp;readfds)) {
        recv(s1, buf1, sizeof(buf1), 0);
    }
    if (FD_ISSET(s2, &amp;readfds)) {
        recv(s1, buf2, sizeof(buf2), 0);
    }
}
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#pollman">=
<TT>poll()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D setsockopt()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dsetsockoptman><TT>setsockopt()</TT>, =
<TT>getsockopt()</TT></A></H2>
<P></P>
<P>Set various options for a socket</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/types.h&gt;</TT><BR><TT>#include=20
  &lt;sys/socket.h&gt;</TT></P>
  <P><TT>int getsockopt(int s, int level, int optname, void=20
  =
*optval,</TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs=
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socklen_t=20
  *optlen);</TT><BR><TT>int setsockopt(int s, int level, int optname, =
const void=20
  =
*optval,</TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs=
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socklen_t=20
  optlen);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>Sockets are fairly configurable beasts. In fact, they are so =
configurable,=20
  I'm not even going to cover it all here. It's probably =
system-dependent=20
  anyway. But I will talk about the basics.</P>
  <P>Obviously, these functions get and set certain options on a socket. =
On a=20
  Linux box, all the socket information is in the man page for socket in =
section=20
  7. (Type: "<B><TT>man 7 socket</TT></B>" to get all these =
goodies.)</P>
  <P>As for parameters, <B><TT>s</TT></B> is the socket you're talking =
about,=20
  level should be set to <B><TT>SOL_SOCKET</TT></B>. Then you set the=20
  <B><TT>optname</TT></B> to the name you're interested in. Again, see =
your man=20
  page for all the options, but here are some of the most fun ones:</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>SO_BINDTODEVICE</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>Bind this socket to a symbolic device name like <TT>eth0</TT> =
instead=20
        of using <TT>bind()</TT> to bind it to an IP address. Type the =
command=20
        <B><TT>ifconfig</TT></B> under Unix to see the device =
names.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft <p><B><TT>SO_REUSEADDR</TT></B>
        <P></P></TD>
      <TD vAlign=3Dtop align=3Dleft <p>Allows other sockets to =
<TT>bind()</TT> to=20
        this port, unless there is an active listening socket bound to =
the port=20
        already. This enables you to get around those "Address already =
in use"=20
        error messages when you try to restart your server after a =
crash.
        <P></P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft <p><B><TT>SO_BROADCAST</TT></B>
        <P></P></TD>
      <TD vAlign=3Dtop align=3Dleft <p>Allows UDP datagram=20
        (<B><TT>SOCK_DGRAM</TT></B>) sockets to send and recieve packets =
sent to=20
        and from the broadcast address. Does =
nothing--<I>NOTHING!!</I>--to TCP=20
        stream sockets! Hahaha!
        <P></P></TD></TR></TBODY></TABLE></P>
  <P>As for the parameter <B><TT>optval</TT></B>, it's usually a pointer =
to an=20
  <TT>int</TT> indicating the value in question. For booleans, zero is =
false,=20
  and non-zero is true. And that's an absolute fact, unless it's =
different on=20
  your system. If there is no parameter to be passed, =
<B><TT>optval</TT></B> can=20
  be <B><TT>NULL</TT></B>.</P>
  <P>The final parameter, <B><TT>optlen</TT></B>, is filled out for you =
by=20
  <TT>getsockopt()</TT> and you have to specify it for =
<TT>getsockopt()</TT>,=20
  where it will probably be <TT>sizeof(int)</TT>.</P>
  <P><B>Warning</B>: on some systems (notably Sun and Windows), the =
option can=20
  be a <TT>char</TT> instead of an <TT>int</TT>, and is set to, for =
example, a=20
  character value of <TT>'1'</TT> instead of an <TT>int</TT> value of=20
  <B><TT>1</TT></B>. Again, check your own man pages for more info with=20
  "<B><TT>man setsockopt</TT></B>" and "<B><TT>man 7=20
socket</TT></B>"!</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns zero on success, or <B><TT>-1</TT></B> on error (and =
<TT>errno</TT>=20
  will be set accordingly.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int optval;
int optlen;
char *optval2;

// set SO_REUSEADDR on a socket to true (1):
optval =3D 1;
setsockopt(s1, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));

// bind a socket to a device name (might not work on all systems):
optval2 =3D "eth1"; // 4 bytes long, so 4, below:
setsockopt(s2, SOL_SOCKET, SO_BINDTODEVICE, optval2, 4);

// see if the SO_BROADCAST flag is set:
getsockopt(s3, SOL_SOCKET, SO_BROADCAST, &amp;optval, &amp;optlen);
if (optval !=3D 0) {
    print("SO_BROADCAST enabled on s3!\n");
}
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#fcntlman"=
><TT>fcntl()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D send(), sendto()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dsendman><TT>send()</TT>, <TT>sendto()</TT></A></H2>
<P></P>
<P>Send data out over a socket</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/types.h&gt;</TT><BR><TT>#include=20
  &lt;sys/socket.h&gt;</TT></P>
  <P><TT>ssize_t send(int s, const void *buf, size_t=20
  =
len,</TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
bsp;&nbsp;&nbsp;&nbsp;int=20
  flags);</TT></P>
  <P><TT>ssize_t sendto(int s, const void *buf, size_t=20
  =
len,</TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int=20
  flags, const struct sockaddr=20
  =
*to,</TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socklen_t=20
  tolen);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>These functions send data to a socket. Generally speaking, =
<TT>send()</TT>=20
  is used for TCP <B><TT>SOCK_STREAM</TT></B> connected sockets, and=20
  <TT>sendto()</TT> is used for UDP <B><TT>SOCK_DGRAM</TT></B> =
unconnected=20
  datagram sockets. With the unconnected sockets, you must specify the=20
  destination of a packet each time you send one, and that's why the =
last=20
  parameters of <TT>sendto()</TT> define where the packet is going.</P>
  <P>With both <TT>send()</TT> and <TT>sendto()</TT>, the parameter=20
  <B><TT>s</TT></B> is the socket, <B><TT>buf</TT></B> is a pointer to =
the data=20
  you want to send, <B><TT>len</TT></B> is the number of bytes you want =
to send,=20
  and <B><TT>flags</TT></B> allows you to specify more information about =
how the=20
  data is to be sent. Set <B><TT>flags</TT></B> to zero if you want it =
to be=20
  "normal" data. Here are some of the commonly used flags, but check =
your local=20
  <TT>send()</TT> man pages for more details:</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>MSG_OOB</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>Send as "out of band" data. TCP supports this, and it's a way =
to tell=20
        the receiving system that this data has a higher priority than =
the=20
        normal data. The receiver will recieve the signal =
<B><TT>SIGURG</TT></B>=20
        and it can then recieve this data without first recieving all =
the rest=20
        of the normal data in the queue.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>MSG_DONTROUTE</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>Don't send this data over a router, just keep it =
local.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>MSG_DONTWAIT</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>If <TT>send()</TT> would block because outbound traffic is =
clogged,=20
        have it return <B><TT>EAGAIN</TT></B>. This is like a "enable=20
        non-blocking just for this send." See the section on <A=20
        =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#blocking"=
>blocking</A>=20
        for more details.</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"30%">
        <P><B><TT>MSG_NOSIGNAL</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"68%">
        <P>If you <TT>send()</TT> to a remote host which is no longer=20
        <TT>recv()</TT>ing, you'll typically get the signal=20
        <B><TT>SIGPIPE</TT></B>. Adding this flag prevents that signal =
from=20
        being raised.</P></TD></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns the number of bytes actually sent, or <B><TT>-1</TT></B> on =
error=20
  (and <TT>errno</TT> will be set accordingly.) Note that the number of =
bytes=20
  actually sent might be less than the number you asked it to send! See =
the=20
  section on <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#sendall">=
handling=20
  partial <TT>send()</TT>s</A> for a helper function to get around =
this.</P>
  <P>Also, if the socket has been closed by either side, the process =
calling=20
  <TT>send()</TT> will get the signal <B><TT>SIGPIPE</TT></B>. (Unless=20
  <TT>send()</TT> was called with the <B><TT>MSG_NOSIGNAL</TT></B>=20
  flag.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int spatula_count =3D 3490;
char *secret_message =3D "The Cheese is in The Toaster";

int stream_socket, dgram_socket;
struct sockaddr_in dest;
int temp;

// first with TCP stream sockets:
stream_socket =3D socket(PF_INET, SOCK_STREAM, 0);
.
.
.
// convert to network byte order
temp =3D htonl(spatula_count);
// send data normally:
send(stream_socket, &amp;temp, sizeof(temp), 0);

// send secret message out of band:
send(stream_socket, secret_message, strlen(secret_message)+1, MSG_OOB);

// now with UDP datagram sockets:
dgram_socket =3D socket(PF_INET, SOCK_DGRAM, 0);
.
.
.
// build destination
dest.sin_family =3D AF_INET;
inet_aton("10.0.0.1", &amp;dest.sin_addr);
dest.sin_port =3D htons(2223);

// send secret message normally:
sendto(dgram_socket, secret_message, strlen(secret_message)+1, 0,=20
       (struct sockaddr*)&amp;dest, sizeof(dest));
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#recvman">=
<TT>recv()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#recvman">=
<TT>recvfrom()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D shutdown()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dshutdownman><TT>shutdown()</TT></A></H2>
<P></P>
<P>Stop further sends and recieves on a socket</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/socket.h&gt;</TT></P>
  <P><TT>int shutdown(int s, int how);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>That's it! I've had it! No more <TT>send()</TT>s are allowed on =
this=20
  socket, but I still want to <TT>recv()</TT> data on it! Or vice-versa! =
How can=20
  I do this?</P>
  <P>When you <TT>close()</TT> a socket descriptor, it closes both sides =
of the=20
  socket for reading and writing, and frees the socket descriptor. If =
you just=20
  want to close one side or the other, you can use this =
<TT>shutdown()</TT>=20
  call.</P>
  <P>As for parameters, <B><TT>s</TT></B> is obviously the socket you =
want to=20
  perform this action on, and what action that is can be specified with =
the=20
  <B><TT>how</TT></B> paramter. How can be <B><TT>SHUT_RD</TT></B> to =
prevent=20
  further <TT>recv()</TT>s, <B><TT>SHUT_WR</TT></B> to prohibit further=20
  <TT>send()</TT>s, or <B><TT>SHUT_RDWR</TT></B> to do both.</P>
  <P>Note that <TT>shutdown()</TT> doesn't free up the socket =
descriptor, so you=20
  still have to eventually <TT>close()</TT> the socket even if it has =
been fully=20
  shut down.</P>
  <P>This is a rarely used system call.</P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>Returns zero on success, or <B><TT>-1</TT></B> on error (and =
<TT>errno</TT>=20
  will be set accordingly.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s =3D socket(PF_INET, SOCK_STREAM, =
0);

// ...do some send()s and stuff in here...

// and now that we're done, don't allow any more sends()s:
shutdown(s, SHUT_RD);
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#closeman"=
><TT>close()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D socket()=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dsocketman><TT>socket()</TT></A></H2>
<P></P>
<P>Allocate a socket descriptor</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P><TT>#include &lt;sys/types.h&gt;</TT><BR><TT>#include=20
  &lt;sys/socket.h&gt;</TT></P>
  <P><TT>int socket(int domain, int type, int =
protocol);</TT></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>Returns a new socket descriptor that you can use to do sockety =
things with.=20
  This is generally the first call in the whopping process of writing a =
socket=20
  program, and you can use the result for subsequent calls to =
<TT>listen()</TT>,=20
  <TT>bind()</TT>, <TT>accept()</TT>, or a variety of other =
functions.</P>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD vAlign=3Dtop align=3Dleft width=3D"20%">
        <P><B><TT>domain</TT></B></P></TD>
      <TD vAlign=3Dtop align=3Dleft width=3D"78%">
        <P><B><TT>domain</TT></B> describes what kind of socket you're=20
        interested in. This can, believe me, be a wide variety of =
things, but=20
        since this is a socket guide, it's going to be =
<B><TT>PF_INET</TT></B>=20
        for you. And, correspondingly, when you load up your <TT>struct=20
        sockaddr_in</TT> to use with this socket, you're going to set =
the=20
        <TT>sin_family</TT> field to <B><TT>AF_INET</TT></B></P>
        <P>(Also of interest is <B><TT>PF_INET6</TT></B> if you're going =
to be=20
        doing IPv6 stuff. If you don't know what that is, don't worry =
about=20
        it...yet.)</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft <p><B><TT>type</TT></B>
        <P></P></TD>
      <TD vAlign=3Dtop align=3Dleft <p>Also, the <B><TT>type</TT></B> =
parameter=20
        can be a number of things, but you'll probably be setting it to =
either=20
        <B><TT>SOCK_STREAM</TT></B> for reliable TCP sockets =
(<TT>send()</TT>,=20
        <TT>recv()</TT>) or <B><TT>SOCK_DGRAM</TT></B> for unreliable =
fast UDP=20
        sockets (<TT>sendto()</TT>, <TT>recvfrom()</TT>.)
        <P></P>
        <P>(Another interesting socket type is <B><TT>SOCK_RAW</TT></B> =
which=20
        can be used to construct packets by hand. It's pretty =
cool.)</P></TD></TR>
    <TR>
      <TD vAlign=3Dtop align=3Dleft <p><B><TT>protocol</TT></B>
        <P></P></TD>
      <TD vAlign=3Dtop align=3Dleft <p>Finally, the =
<B><TT>protocol</TT></B>=20
        parameter tells which protocol to use with a certain socket =
type. Like=20
        I've already said, for instance, <B><TT>SOCK_STREAM</TT></B> =
uses TCP.=20
        Fortunately for you, when using <B><TT>SOCK_STREAM</TT></B> or=20
        <B><TT>SOCK_DGRAM</TT></B>, you can just set the protocol to 0, =
and=20
        it'll use the proper protocol automatically. Otherwise, you can =
use=20
        <TT>getprotobyname()</TT> to look up the proper protocol number.
        <P></P></TD></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>Return Value</B>=20
  <DD>
  <P>The new socket descriptor to be used in subsequent calls, or=20
  <B><TT>-1</TT></B> on error (and <TT>errno</TT> will be set=20
  accordingly.)</P></DD></DL>
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>int s1, s2;

s1 =3D socket(PF_INET, SOCK_STREAM, 0);
s2 =3D socket(PF_INET, SOCK_DGRAM, 0);

if (s1 =3D=3D -1) {
    perror("socket");
}
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#acceptman=
"><TT>accept()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#bindman">=
<TT>bind()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#listenman=
"><TT>listen()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D sockaddr_in, in_addr=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  -->
<P>
<HR>

<H2><A name=3Dsockaddr_inman><TT>struct sockaddr_in</TT>, <TT>struct=20
in_addr</TT></A></H2>
<P></P>
<P>Structures for handling internet addresses</P>
<DL>
  <DT><B>Prototypes</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>#include &lt;netinet/in.h&gt;

struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};

struct in_addr {
    unsigned long s_addr;  // load with inet_aton()
};
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>Description</B>=20
  <DD>
  <P>These are the basic structures for all syscalls and functions that =
deal=20
  with internet addresses. In memory, the <TT>struct sockaddr_in</TT> is =
the=20
  same size as <TT>struct sockaddr</TT>, and you can freely cast the =
pointer of=20
  one type to the other without any harm, except the possible end of the =

  universe.</P>
  <P>Just kidding on that end-of-the-universe thing...if the universe =
does end=20
  when you cast a <TT>struct sockaddr_in*</TT> to a <TT>struct =
sockaddr*</TT>, I=20
  promise you it's pure coincidence and you shouldn't even worry about =
it.</P>
  <P>So, with that in mind, remember that whenever a function says it =
takes a=20
  <TT>struct sockaddr*</TT> you can cast your <TT>struct =
sockaddr_in*</TT> to=20
  that type with ease and safety.</P>
  <P>There's also this <TT>sin_zero</TT> field which some people claim =
must be=20
  set to zero. Other people don't claim anything about it (the Linux=20
  documentation doesn't even mention it at all), and setting it to zero =
doesn't=20
  seem to be actually necessary. So, if you feel like it, set it to zero =
using=20
  <TT>memset()</TT>.</P>
  <P>Now, that <TT>struct in_addr</TT> is a weird beast on different =
systems.=20
  Sometimes it's a crazy <TT>union</TT> with all kinds of =
<TT>#define</TT>s and=20
  other nonsense. But what you should do is only use the =
<B><TT>s_addr</TT></B>=20
  field in this structure, because many systems only implement that =
one.</P>
  <P>With IPv4 (what basically everyone in 2005 still uses), the =
<TT>struct=20
  s_addr</TT> is a 4-byte number that represents one digit in an IP =
address per=20
  byte. (You won't ever see an IP address with a number in it greater =
than=20
  255.)</P></DD></DL><!-- =0A=
<rvalue>=0A=
</rvalue>=0A=
 -->
<DL>
  <DT><B>Example</B>=20
  <DD>
  <P>
  <TABLE cellSpacing=3D0 cellPadding=3D10 border=3D0>
    <TBODY>
    <TR>
      <TD bgColor=3D#cfcfcf><PRE>struct sockaddr_in myaddr;
int s;

myaddr.sin_family =3D AF_INET;
myaddr.sin_port =3D htons(3490);
inet_aton("63.161.169.137", &amp;myaddr.sin_addr.s_addr);

s =3D socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)myaddr, sizeof(myaddr));
</PRE></TR></TBODY></TABLE></P></DD></DL>
<DL>
  <DT><B>See Also</B>=20
  <DD>
  <P><A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#acceptman=
"><TT>accept()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#bindman">=
<TT>bind()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#connectma=
n"><TT>connect()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#inet_ntoa=
man"><TT>inet_aton()</TT></A>,=20
  <A=20
  =
href=3D"http://beej.us/guide/bgnet/output/htmlsingle/bgnet.html#inet_ntoa=
man"><TT>inet_ntoa()</TT></A></P></DD></DL><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=3D=3D manpage header=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D  --><!--  <manpage id=3D"">=0A=
<title><func></func></title>=0A=
<short><p></p></short>=0A=
=0A=
<prototypes>=0A=
<p><tt>#include &lt;sys/.h&gt;</tt><br/>=0A=
<tt>#include &lt;sys/.h&gt;</tt></p>=0A=
<p><tt></tt><br/>=0A=
<tt></tt></p>=0A=
</prototypes>=0A=
=0A=
<description>=0A=
</description>=0A=
=0A=
<rvalue>=0A=
<p>Returns zero on success, or <const>-1</const> on error (and=0A=
<func>errno</func> will be set accordingly.)</p>=0A=
</rvalue>=0A=
=0A=
<example>=0A=
<code>=0A=
</code>=0A=
</example>=0A=
=0A=
<seealso>=0A=
<p><link dest=3D"socketman"><func>socket()</func></link>,=0A=
<link dest=3D"shutdownman"><func>shutdown()</func></link></p>=0A=
</seealso>=0A=
=0A=
</manpage>  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  reference  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<HR>

<H2>9. <A name=3Dreference>More References</A></H2>
<P></P>
<P>You've come this far, and now you're screaming for more! Where else =
can you=20
go to learn more about all this stuff?</P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  books  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>9.1. <A name=3Dbooks>Books</A></H3>
<P></P>
<P>For old-school actual hold-it-in-your-hand pulp paper books, try some =
of the=20
following excellent guides. Note the prominent Amazon.com logo. What all =
this=20
shameless commercialism means is that I basically get a kickback =
(Amazon.com=20
store credit, actually) for selling these books through this guide. So =
if you're=20
going to order one of these books anyway, why not send me a special =
thank you by=20
starting your spree from one of the links, below.</P>
<P>Besides, more books for me might ultimately lead to more guides for =
you.=20
<TT>;-)</TT></P>
<P><A =
href=3D"http://www.amazon.com/exec/obidos/redirect-home/beejsguides-20"><=
IMG=20
alt=3DNone=20
src=3D"http://beej.us/guide/bgnet/output/htmlsingle/home-logo-130x60w.png=
">=20
</A></P>
<P><I>Unix Network Programming, volumes 1-2</I> by W. Richard Stevens. =
Published=20
by Prentice Hall. ISBNs for volumes 1-2: <A=20
href=3D"http://www.amazon.com/exec/obidos/ASIN/013490012X/beejsguides-20"=
>013490012X</A>,=20
<A=20
href=3D"http://www.amazon.com/exec/obidos/ASIN/0130810819/beejsguides-20"=
>0130810819</A>.=20
</P>
<P><I>Internetworking with TCP/IP, volumes I-III</I> by Douglas E. Comer =
and=20
David L. Stevens. Published by Prentice Hall. ISBNs for volumes I, II, =
and III:=20
<A=20
href=3D"http://www.amazon.com/exec/obidos/ASIN/0130183806/beejsguides-20"=
>0130183806</A>,=20
<A=20
href=3D"http://www.amazon.com/exec/obidos/ASIN/0139738436/beejsguides-20"=
>0139738436</A>,=20
<A=20
href=3D"http://www.amazon.com/exec/obidos/ASIN/0138487146/beejsguides-20"=
>0138487146</A>.=20
</P>
<P><I>TCP/IP Illustrated, volumes 1-3</I> by W. Richard Stevens and Gary =
R.=20
Wright. Published by Addison Wesley. ISBNs for volumes 1, 2, and 3: <A=20
href=3D"http://www.amazon.com/exec/obidos/ASIN/0201633469/beejsguides-20"=
>0201633469</A>,=20
<A=20
href=3D"http://www.amazon.com/exec/obidos/ASIN/020163354X/beejsguides-20"=
>020163354X</A>,=20
<A=20
href=3D"http://www.amazon.com/exec/obidos/ASIN/0201634953/beejsguides-20"=
>0201634953</A>.=20
</P>
<P><I>TCP/IP Network Administration</I> by Craig Hunt. Published by =
O'Reilly=20
&amp; Associates, Inc. ISBN <A=20
href=3D"http://www.amazon.com/exec/obidos/ASIN/1565923227/beejsguides-20"=
>1565923227</A>.=20
</P>
<P><I>Advanced Programming in the UNIX Environment</I> by W. Richard =
Stevens.=20
Published by Addison Wesley. ISBN <A=20
href=3D"http://www.amazon.com/exec/obidos/ASIN/0201563177/beejsguides-20"=
>0201563177</A>.=20
</P>
<P><I>Using C on the UNIX System</I> by David A. Curry. Published by =
O'Reilly=20
&amp; Associates, Inc. ISBN 0937175234. <I>Out of print.</I></P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  webref  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>9.2. <A name=3Dwebref>Web References</A></H3>
<P></P>
<P>On the web:</P>
<P><I><A href=3D"http://www.cs.umn.edu/~bentlema/unix/">BSD Sockets: A =
Quick And=20
Dirty Primer</A></I> (has other great Unix system programming info, =
too!)</P>
<P><I><A href=3D"http://www.developerweb.net/sock-faq/">The Unix Socket=20
FAQ</A></I></P>
<P><I><A =
href=3D"http://pandonia.canberra.edu.au/ClientServer/">Client-Server=20
Computing</A></I></P>
<P><I><A href=3D"http://pclt.cis.yale.edu/pclt/COMM/TCPIP.HTM">Intro to=20
TCP/IP</A></I></P>
<P><I><A=20
href=3D"http://www.doc.ic.ac.uk/~ih/doc/pc_conn/tcpip/intro/intro0.html">=
Another=20
Different Intro to TCP/IP</A></I></P>
<P><I><A=20
href=3D"http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/">TCP/I=
P=20
FAQ</A></I></P>
<P><I><A href=3D"http://tangentsoft.net/wskfaq/">The Winsock =
FAQ</A></I></P><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  --><!--  rfcs  --><!--  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D  -->
<P><BR>
<H3>9.3. <A name=3Drfcs>RFCs</A></H3>
<P></P>
<P><A href=3D"http://www.rfc-editor.org/">RFCs</A>--the real dirt:</P>
<P><I><A =
href=3D"http://www.rfc-editor.org/rfc/rfc768.txt">RFC-768</A></I>--The=20
User Datagram Protocol (UDP)</P>
<P><I><A =
href=3D"http://www.rfc-editor.org/rfc/rfc791.txt">RFC-791</A></I>--The=20
Internet Protocol (IP)</P>
<P><I><A =
href=3D"http://www.rfc-editor.org/rfc/rfc793.txt">RFC-793</A></I>--The=20
Transmission Control Protocol (TCP)</P>
<P><I><A =
href=3D"http://www.rfc-editor.org/rfc/rfc854.txt">RFC-854</A></I>--The=20
Telnet Protocol</P>
<P><I><A =
href=3D"http://www.rfc-editor.org/rfc/rfc951.txt">RFC-951</A></I>--The=20
Bootstrap Protocol (BOOTP)</P>
<P><I><A =
href=3D"http://www.rfc-editor.org/rfc/rfc1350.txt">RFC-1350</A></I>--The =

Trivial File Transfer Protocol (TFTP)</P><!--  reference  =
--></BODY></HTML>

------=_NextPart_000_0000_01C722B4.E82699D0
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: http://beej.us/guide/bgnet/output/htmlsingle/dataencap.png

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
A2RDV7AAAAAASUVORK5CYII=

------=_NextPart_000_0000_01C722B4.E82699D0
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: http://beej.us/guide/bgnet/output/htmlsingle/cs.png

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
AElFTkSuQmCC

------=_NextPart_000_0000_01C722B4.E82699D0
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: http://beej.us/guide/bgnet/output/htmlsingle/home-logo-130x60w.png

iVBORw0KGgoAAAANSUhEUgAAAIIAAAA8CAMAAACdHZLKAAAAYFBMVEUAAAD88+OHh4dra2v76Mrz
xXb++fH+/v78/Pz4+PhFRUU1NTX//fslJSX///66urqoqKja2dn//v3++/iamZlWVlb////x8fH3
16Hr6+v/mQDvr0YYGBjJyckODg4GBgY9hAjoAAAEv0lEQVRYhe2Y3XbrKAyFKcSNDfVgWgMhMfj9
33K2hJ2/Ju2cNT1tL8JFwEISH0KmcoX4BS38cHsgPBAeCDcRpHRB5hDGZWLggVNay2MXRq1ZPHit
HJuwnqTmqo9V58wXLK3lJygsujQ1XiOoFHodgl4QaA38uuDksYNOUuhH6A4Dm7CetcbaVH2sOme+
dAreh6RZYdGlKX2FYGklZVe5lSQIJvHT2oVqaE4mi54+CladM19yCF6HQVaFKr2LANJFjr3RaDC9
H47daqxPJoveCeGoc/KVVZYqA+kMoWi0WwhBjlWeipRmqA5MXjuzhOIUhVXvKgrm3BcepR2kDv8p
CiGZKh+ltYOCFGPv1k6NlAeB+5TJZNU7Iaw6J18wJST/KYLpM8lkletUf3zP+b10SRlDKZjwghhL
JquePvpYdU6+MCAEuSjcR/i59kB4IPw+hO+tVo/tHOEn2wPhgfBA+L0ITvVzL6kAQJmbk+pRlOGv
P5exYWt9KWboAtUdtVEdk6QxVDaHOMqhG7QZ29VZ6SVpQ2Uq7MOO7TBNKLGcn727hTAUvrB6qsOF
8AbjyfIvyoxW1evMw+syFKg48kSDGdWMm4XmCcnOMDEV1nZGTBP70JMU0ywGW8rEy1wjOHjTHhh6
Swgzr1KpFEMVr+sKSpRC06jLeyEMKGdLCCwUE4URE7JLXoBNC9V1UvQRI4RgEH3vU/QL6gUC7Rwl
Fvw5Ggtpe1rdat6uF3DX1nF0CVsTJZO27gJLgSB0hkBQsSuFaSkyBq4MHYcXA/QkjzSmstDvEWK2
9G20IsCF4i2NvKyzth5BtZQ1Hpp/YVMSIeQQgU0pUlcLSsdlNGJ/eqEjQZpNeysdpe7LilAj0ne0
AC3bWqX7eUHIUFNtiDi7gdNAZDqIFFrDCF3PIIFV+FMgY09aOEYgQbyJQDtD4txGSJQHU6kIEQtR
eGNhBOosIcQVARK7xHYZZbj6FIHCOZwO4goBuWDcehB0Qvwi1iik9wjTEeFPomA48+8g8CoMAgRL
b0N2HS8o+Xl2Fwjo+KtZKgRM1g1SLnyCUBgBi0DlHQIdt+X3to9buitmMfcjhcPXCIULBEzQt5Mr
PZxw9igwXSGEZNO7KEySLxdzIwpY3IyGr56uLFfT1LkiZqVmemHPEXLMfEIKEcANMVKg8G5dIcRR
jZcIY3Xb30Tg6OCxVIQJ33MTLblclMjNE0K2MJaiSM8ZM4JSlvoKXyCk0V8htLLMs8l5on9fzHQo
Usy4RWwhHKfnuShc92PolN1Cv7Mqhg7OcW0mulxnXIBbjRuLEFqFid5Wv1CRMPGlIlhOU90Ocri+
FxKlWIjt9rWNEaOOf+s4tC4neiDFp13TNJu3amTriW5jpDnYtFtHI2dzDBcqXWT0yHkI7Y4d3/xj
vWuerkXn7bXZc9t9pPQn7QbCc7P/COJl8/T29nT4qwiIw37fbF7u2myaJhz2H4bqfyOEzWG/PzSb
5/czb5sd5nZP++arCO4Vbi87Pu9Ds0PYX15D+Ofl7Xmzaw4kxTHtvi4I92vH591hv7RDbctTs0FK
Hr4sEz4sX982zZFibc3uqfK9fgtCoOxH7A9LKHAoN5LjbyN8S3sgPBAeCFcIP97+BbyqMXwp+4Oq
AAAAAElFTkSuQmCC

------=_NextPart_000_0000_01C722B4.E82699D0
Content-Type: text/css;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://beej.us/guide/bgnet/output/htmlsingle/bgnet.css

BODY {
	COLOR: black; FONT-FAMILY: "Book Antiqua", Georgia, Palatino, Times, =
"Times New Roman", serif; BACKGROUND-COLOR: white
}
#adsense {
	MARGIN-TOP: 20px; FLOAT: right; MARGIN-LEFT: 20px
}

------=_NextPart_000_0000_01C722B4.E82699D0--
