From: <Guardado pelo Windows Internet Explorer 7>
Subject: Programming IP Sockets on Linux, Part One
Date: Fri, 31 Oct 2008 17:41:02 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0000_01C93B7F.D7E2CC20"
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.5579

This is a multi-part message in MIME format.

------=_NextPart_000_0000_01C93B7F.D7E2CC20
Content-Type: text/html;
	charset="Windows-1252"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://gnosis.cx/publish/programming/sockets.html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Programming IP Sockets on Linux, Part One</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dwindows-1252">
<META content=3D"MSHTML 6.00.6000.16735" name=3DGENERATOR></HEAD>
<BODY>
<H1>Programming IP Sockets on Linux, Part One</H1>
<P>by David Mertz, Ph.D. &lt;mertz@gnosis.cx&gt;</P>
<HR>

<H2 align=3Dcenter>Before you start</H2>
<HR>

<P>(see also <A =
href=3D"http://gnosis.cx/publish/programming/sockets2.html">Part=20
Two</A> of this tutorial)</P>
<H3>About this tutorial</H3>
<P>IP sockets are the lowest level layer upon which high level internet=20
protocols are built--every thing from HTTP, to SSL, to POP3, to =
Kerberos, to=20
UDP-Time. To implement custom protocols, or to customize implementation =
of=20
well-known protocols, a programmer needs a working knowledge of the =
basic socket=20
infrastructure. A similar API is available in many languages; this =
tutorial=20
focuses primarily on C programming, but it also uses Python as a =
representative=20
higher-level language for examples. </P>
<P>Readers of this tutorial will be introduced to the basics of =
programming=20
custom network tools using the cross-platform Berkeley Sockets =
Interface. Almost=20
all network tools in Linux and other Unix-based operating systems rely =
on this=20
interface. </P>
<H3>Prerequisites</H3>
<P>This tutorial requires a minimal level of knowledge of C, and ideally =
of=20
Python also (mostly for part two). However, readers who are not familiar =
with=20
either programming language should be able to make it through with a bit =
of=20
extra effort; most of the underlying concepts will apply equally to =
other=20
programming languages, and calls will be quite similar in most =
high-level=20
scripting languages like Ruby, Perl, TCL, etc. </P>
<P>While this tutorial introduces the basic concepts behind IP (internet =

protocol) networks, it certainly does not hurt readers to have some =
prior=20
acquaintance with the concept of network protocols and layers. </P>
<H3>About the author</H3>
<P>David Mertz is a writer, a programmer, and a teacher, who always =
endeavors to=20
improve his communication to readers (and tutorial takers). He welcomes =
any=20
comments, please direct them to <A>&lt;mertz@gnosis.cx&gt;</A> . </P>
<P>David also wrote the book <A>Text Processing in Python</A> which =
readers can=20
read online at <A>http://gnosis.cx/TPiP/</A> </P>
<HR>

<H2 align=3Dcenter>Understanding IP Networks and Network Layers</H2>
<HR>

<H3>What is a network?</H3>
<P>What we usually call a computer network is composed of a number of=20
<A>"network layers"</A> , each providing a different restriction and/or=20
guarantee about the data at that layer. The protocols at each network =
layer=20
generally have their own packet formats, headers, and layout. </P>
<P>The seven traditional layers of a network are divided into two =
groups: upper=20
layers and lower layers. The sockets interface provides a uniform API to =
the=20
lower layers of a network, and allows you to implement upper layers =
within your=20
sockets application. Further, application data formats may themselves =
constitute=20
further layers, e.g. SOAP is built on top of XML, and ebXML may itself =
utilize=20
SOAP. In any case, anything past layer 4 is outside the scope of this =
tutorial.=20
</P><IMG =
src=3D"http://gnosis.cx/publish/programming/network-layers.png">=20
<H3>What do sockets do?</H3>
<P>While the sockets interface theoretically allows access to =
<I>protocol=20
families</I> other than IP, in practice, every network layer you use in =
your=20
sockets application will use IP. For this tutorial we only look at IPv4; =
in the=20
future IPv6 will become important also, but the principles are the same. =
At the=20
transport layer, sockets support two specific protocols: TCP =
(transmission=20
control protocol) and UDP (user datagram protocol). </P>
<P>Sockets cannot be used to access lower (or higher) network layers; =
for=20
example, a socket application does not know whether it is running over =
ethernet,=20
token ring, or a dialup connection. Nor does the sockets pseudo-layer =
know=20
anything about higher-level protocols like NFS, HTTP, FTP, and the like =
(except=20
in the sense that you might yourself write a sockets application that =
implements=20
those higher-level protocols). </P>
<P>At times, the sockets interface is not your best choice for a network =

programming API. Specifically, many excellent libraries exist (in =
various=20
languages) to use higher-level protocols directly, without having to =
worry about=20
the details of sockets--the libraries handle those details for you. =
While there=20
is nothing wrong with writing your own SSH client, for example, there is =
not=20
need to do so simply to let an application transfer data securely. =
Lower-level=20
layers than those sockets address fall pretty much in the domain of =
device=20
driver programming. </P>
<H3>IP, TCP and UDP</H3>
<P>As the last panel indicated, when you program a sockets application, =
you have=20
a choice to make between using TCP and using UDP. Each has its own =
benefits and=20
disadvantages. </P>
<P>TCP is a stream protocol, while UDP is a datagram protocol. That is =
to say,=20
TCP establishes a continuous open connection between a client and a =
server, over=20
which bytes may be written--and correct order guaranteed--for the life =
of the=20
connection. However, bytes written over TCP have no built-in structure, =
so=20
higher-level protocols are required to delimit any data records and =
fields=20
within the transmitted bytestream. </P>
<P>UDP, on the other hand, does not require that any connection be =
established=20
between client and server, it simply transmits a message between =
addresses. A=20
nice feature of UDP is that its packets are self-delimiting--each =
datagram=20
indicates exactly where it begins and ends. A possible disadvantage of =
UDP,=20
however, is that it provides no guarantee that packets will arrive =
in-order, or=20
even at all. Higher-level protocols built on top of UDP may, of course, =
provide=20
handshaking and acknowledgements. </P>
<P>A useful analogy for understanding the difference between TCP and UDP =
is the=20
difference between a telephone call and posted letters. The telephone =
call is=20
not active until the caller "rings" the receiver and the receiver picks =
up. The=20
telephone channel remains alive as long as the parties stay on the =
call--but=20
they are free to say as much or as little as they wish to during the =
call. All=20
remarks from either party occur in temporal order. On the other hand, =
when you=20
send a letter, the post office starts delivery without any assurance the =

recipient exists, nor any strong guarantee about how long delivery will =
take.=20
The recipient may receive various letters in a different order than they =
were=20
sent, and the sender may receive mail interspersed in time with those =
she sends.=20
Unlike with the USPS, undeliverable mail always goes to the dead letter =
office,=20
and is not returned to sender. </P>
<H3>Peers, ports, names, and addresses</H3>
<P>Beyond the protocol--TCP or UDP--there are two things a peer (a =
client or=20
server) needs to know about the machine it communicates with: An IP =
address and=20
a port. An IP address is a 32-bit data value, usually represented for =
humans in=20
"dotted quad" notation, e.g., <CODE>64.41.64.172</CODE> . A port is a =
16-bit=20
data value, usually simply represented as a number less than 65536--most =
often=20
one in the tens or hundreds range. An IP address gets a packet <I>to</I> =
a=20
machine, a port lets the machine decide which process/service (if any) =
to direct=20
it to. That is a slight simplification, but the idea is correct. </P>
<P>The above description is almost right, but it misses something. Most =
of the=20
time when humans think about an internet host (peer), we do not remember =
a=20
number like <CODE>64.41.64.172</CODE> , but instead a name like=20
<CODE>gnosis.cx</CODE> . To find the IP address associated with a =
particular=20
host name, usually you use a Domain Name Server, but sometimes local =
lookups are=20
used first (often via the contents of <CODE>/etc/hosts</CODE> ). For =
this=20
tutorial, we will generally just assume an IP address is available, but =
the next=20
panel discusses coding name/address lookups. </P>
<H3>Host name resolution</H3>
<P>The command-line utility <CODE>nslookup</CODE> can be used to find a =
host IP=20
address from a symbolic name. Actually, a number of common utilities, =
such as=20
<CODE>ping</CODE> or network configuration tools, do the same thing in =
passing.=20
But it is simple to do the same thing programmatically. </P>
<P>In Python or other very-high-level scripting languages, writing a =
utility=20
program to find a host IP address is trivial: </P><PRE>=20
          #!/usr/bin/env python
          "USAGE: nslookup.py &lt;inet_address&gt;"
          import socket, sys
          print socket.gethostbyname(sys.argv[1])
           </PRE>
<P>The trick is using a wrapped version of the same=20
<CODE>gethostbyname())</CODE> function we also find in C. Usage is as =
simple as:=20
</P><PRE>=20
          $ ./nslookup.py gnosis.cx
          64.41.64.172
           </PRE>
<H3>Host name resolution, continued</H3>
<P>In C, that standard library call <CODE>gethostbyname()</CODE> is used =
for=20
name lookup. The below is a simple implementation of =
<CODE>nslookup</CODE> as a=20
command-line tool; adapting it for use in a larger application is=20
straightforward. Of course, C is a bit more finicky than Python is. =
</P><PRE>=20
          /* Bare nslookup utility (w/ minimal error checking) */
          #include &lt;stdio.h&gt;          /* stderr, stdout */
          #include &lt;netdb.h&gt;          /* hostent struct, =
gethostbyname() */
          #include &lt;arpa/inet.h&gt;      /* inet_ntoa() to format IP =
address */
          #include &lt;netinet/in.h&gt;     /* in_addr structure */

          int main(int argc, char **argv) {
            struct hostent *host;     /* host information */
            struct in_addr h_addr;    /* internet address */
            if (argc !=3D 2) {
              fprintf(stderr, "USAGE: nslookup &lt;inet_address&gt;\n");
              exit(1);
            }
            if ((host =3D gethostbyname(argv[1])) =3D=3D NULL) {
              fprintf(stderr, "(mini) nslookup failed on '%s'\n", =
argv[1]);
              exit(1);
            }
            h_addr.s_addr =3D *((unsigned long *) =
host-&gt;h_addr_list[0]);
            fprintf(stdout, "%s\n", inet_ntoa(h_addr));
            exit(0);
          }
           </PRE>
<P>Notice that the returned value from <CODE>gethostbyname()</CODE> is a =

<CODE>hostent</CODE> structure that describes the names host. The member =

<CODE>host-&gt;h_addr_list</CODE> contains a list of addresses, each of =
which is=20
a 32-bit value in "network byte order"--i.e. the endianness may or may =
not be=20
machine native order. In order to convert to dotted-quad form, use the =
function=20
<CODE>inet_ntoa()</CODE> . </P>
<HR>

<H2 align=3Dcenter>Writing a Client Application in C</H2>
<HR>

<H3>The steps in writing a socket client</H3>
<P>My examples for both clients and servers will use one of the simplest =

possible applications: one that sends data and receives the exact same =
thing=20
back. In fact, many machines run an "echo server" for debugging =
purposes; this=20
is convenient for our initial client, since it can be used before we get =
to the=20
server portion (assuming you have a machine with <CODE>echod</CODE> =
running).=20
</P>
<P>I would like to acknowledge the book <I>TCP/IP Sockets in C</I> by =
Donahoo=20
and Calvert (see Resources). I have adapted several examples that they =
present.=20
I recommend the book--but admittedly, echo servers/clients will come =
early in=20
most presentations of sockets programming. </P>
<P>The steps involved in writing a client application differ slightly =
between=20
TCP and UDP clients. In both cases, you first create the socket; in the =
TCP case=20
only, you next establish a connection to the server; next you send some =
data to=20
the server; then receive data back; perhaps the sending and receiving =
alternates=20
for a while; finally, in the TCP case, you close the connection. </P>
<H3>A TCP echo client (client setup)</H3>
<P>First we will look at a TCP client, in the second part of the =
tutorial we=20
will make some adjustments to do (roughly) the same thing with UDP. =
Let's look=20
at the first few lines--some includes, and creating the socket: =
</P><PRE>=20
          #include &lt;stdio.h&gt;
          #include &lt;sys/socket.h&gt;
          #include &lt;arpa/inet.h&gt;
          #include &lt;stdlib.h&gt;
          #include &lt;string.h&gt;
          #include &lt;unistd.h&gt;
          #include &lt;netinet/in.h&gt;

          #define BUFFSIZE 32
          void Die(char *mess) { perror(mess); exit(1); }
           </PRE>
<P>There is not too much to the setup. A particular buffer size is =
defined,=20
which limits the amount of data echo'd at each pass (but we loop through =

multiple passes, if needed). . A small error function is also defined. =
</P>
<H3>A TCP echo client (creating the socket)</H3>
<P>The arguments to the <CODE>socket()</CODE> call decide the type of =
socket:=20
<CODE>PF_INET</CODE> just means it uses IP (which you always will);=20
<CODE>SOCK_STREAM</CODE> and <CODE>IPPROTO_TCP</CODE> go together for a =
TCP=20
socket. </P><PRE>=20
          int main(int argc, char *argv[]) {
            int sock;
            struct sockaddr_in echoserver;
            char buffer[BUFFSIZE];
            unsigned int echolen;
            int received =3D 0;

            if (argc !=3D 4) {
              fprintf(stderr, "USAGE: TCPecho &lt;server_ip&gt; =
&lt;word&gt; &lt;port&gt;\n");
              exit(1);
            }
            /* Create the TCP socket */
            if ((sock =3D socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) =
&lt; 0) {
              Die("Failed to create socket");
            }
           </PRE>
<P>The value returned is a socket handle, which is similar to a file =
handle;=20
specifically, if the socket creation fails, it will return -1 rather =
than a=20
positive numbered handle. </P>
<H3>A TCP echo client (establish connection)</H3>
<P>Now that we have created a socket handle, we need to establish a =
connection=20
with the server. A connection requires a <CODE>sockaddr</CODE> structure =
that=20
describes the server. Specifically, we need to specify the server and =
port to=20
connect to using <CODE>echoserver.sin_addr.s_addr</CODE> and=20
<CODE>echoserver.sin_port</CODE> . The fact we are using an IP address =
is=20
specified with <CODE>echoserver.sin_family</CODE> , but this will always =
be set=20
to <CODE>AF_INET</CODE> . </P><PRE>=20
            /* Construct the server sockaddr_in structure */
            memset(&amp;echoserver, 0, sizeof(echoserver));       /* =
Clear struct */
            echoserver.sin_family =3D AF_INET;                  /* =
Internet/IP */
            echoserver.sin_addr.s_addr =3D inet_addr(argv[1]);  /* IP =
address */
            echoserver.sin_port =3D htons(atoi(argv[3]));       /* =
server port */
            /* Establish connection */
            if (connect(sock,
                        (struct sockaddr *) &amp;echoserver,
                        sizeof(echoserver)) &lt; 0) {
              Die("Failed to connect with server");
            }
           </PRE>
<P>As with creating the socket, the attempt to establish a connection =
will=20
return -1 if the attempt fails. Otherwise, the socket is now ready to =
accept=20
sending and receiving data. </P>
<H3>A TCP echo client (send/receive data)</H3>
<P>Now that the connection is established, we are ready to send and =
receive=20
data. A call to <CODE>send()</CODE> takes as arguments the socket handle =
itself,=20
the string to send, the length of the sent string, and a flag argument. =
Normally=20
the flag is the default value 0. The return value of the =
<CODE>send()</CODE>=20
call is the number of bytes successfully sent. </P><PRE>=20
            /* Send the word to the server */
            echolen =3D strlen(argv[2]);
            if (send(sock, argv[2], echolen, 0) !=3D echolen) {
              Die("Mismatch in number of sent bytes");
            }
            /* Receive the word back from the server */
            fprintf(stdout, "Received: ");
            while (received &lt; echolen) {
              int bytes =3D 0;
              if ((bytes =3D recv(sock, buffer, BUFFSIZE-1, 0)) &lt; 1) =
{
                Die("Failed to receive bytes from server");
              }
              received +=3D bytes;
              buffer[bytes] =3D '\0';        /* Assure null terminated =
string */
              fprintf(stdout, buffer);
            }
           </PRE>
<P>The <CODE>rcv()</CODE> call is not guaranteed to get everything =
in-transit on=20
a particular call--it simply blocks until it gets <I>something</I> . =
Therefore,=20
we loop until we have gotten back as many bytes as were sent, writing =
each=20
partial string as we get it. Obviously, a different protocol might =
decide when=20
to terminate receiving bytes in a different manner (perhaps a delimiter =
within=20
the bytestream). </P>
<H3>A TCP echo client (wrapup)</H3>
<P>Calls to both <CODE>send()</CODE> and <CODE>recv()</CODE> block by =
default,=20
but it is possible to change socket options to allow non-blocking =
sockets.=20
However, this tutorial will not cover details of creating non-blocking =
sockets,=20
nor such other details used in production servers as forking, threading, =
or=20
general asynchronous processing (built on non-blocking sockets). </P>
<P>At the end of the process, we want to call <CODE>close()</CODE> on =
the=20
socket, much as we would with a file handle </P><PRE>=20
           fprintf(stdout, "\n");
           close(sock);
           exit(0);
          }
          </PRE>
<HR>

<H2 align=3Dcenter>Writing a Server Application in C</H2>
<HR>

<H3>The steps in writing a socket server</H3>
<P>A socket server is a bit more complicated than is a client, mostly =
because a=20
server usually needs to be able to handle multiple client requests. =
Basically,=20
there are two aspects to a server: handling each established connection, =
and=20
listening for connections to establish. </P>
<P>In our example, and in most cases, you can split the handling of a =
particular=20
connection into support function--which looks quite a bit like a TCP =
client=20
application does. We name that function <CODE>HandleClient()</CODE> . =
</P>
<P>Listening for new connections is a bit different from client code. =
The trick=20
is that the socket you initially create and bind to an address and port =
is not=20
the actually connected socket. This initial socket acts more like a =
socket=20
factory, producing new connected sockets as needed. This arrangement has =
an=20
advantage in enabling fork'd, threaded, or asynchronously dispatched =
handlers=20
(using <CODE>select()</CODE> ); however, for this first tutorial we will =
only=20
handle pending connected sockets in synchronous order. </P>
<H3>A TCP echo server (application setup)</H3>
<P>Our echo server starts out with pretty much the same few=20
<CODE>#include</CODE> s as the client did, and defines some constants =
and an=20
error handling function: </P><PRE>=20
          #include &lt;stdio.h&gt;
          #include &lt;sys/socket.h&gt;
          #include &lt;arpa/inet.h&gt;
          #include &lt;stdlib.h&gt;
          #include &lt;string.h&gt;
          #include &lt;unistd.h&gt;
          #include &lt;netinet/in.h&gt;

          #define MAXPENDING 5    /* Max connection requests */
          #define BUFFSIZE 32
          void Die(char *mess) { perror(mess); exit(1); }
           </PRE>
<P>The <CODE>BUFFSIZE</CODE> constant limits the data sent per loop. The =

<CODE>MAXPENDING</CODE> constant limits the number of connections that =
will be=20
queued at a time (only one will be <I>serviced</I> at a time in our =
simple=20
server). The <CODE>Die()</CODE> function is the same as in our client. =
</P>
<H3>A TCP echo server (the connection handler)</H3>
<P>The handler for echo connections is straightforward. All it does is =
receive=20
any initial bytes available, then cycle through sending back data and =
receiving=20
more data. For short echo strings (particularly if less than=20
<CODE>BUFFSIZE</CODE> ) and typical connections, only one pass through =
the=20
<CODE>while</CODE> loop will occur. But the underlying sockets interface =
(and=20
TCP/IP) does not make any guarantees about how the bytestream will be =
split=20
between calls to <CODE>recv()</CODE> . </P><PRE>=20
          void HandleClient(int sock) {
            char buffer[BUFFSIZE];
            int received =3D -1;
            /* Receive message */
            if ((received =3D recv(sock, buffer, BUFFSIZE, 0)) &lt; 0) {
              Die("Failed to receive initial bytes from client");
            }
            /* Send bytes and check for more incoming data in loop */
            while (received &gt; 0) {
              /* Send back received data */
              if (send(sock, buffer, received, 0) !=3D received) {
                Die("Failed to send bytes to client");
              }
              /* Check for more data */
              if ((received =3D recv(sock, buffer, BUFFSIZE, 0)) &lt; 0) =
{
                Die("Failed to receive additional bytes from client");
              }
            }
            close(sock);
          }
           </PRE>
<P>The socket that is passed in to the handler function is one that =
already=20
connected to the requesting client. Once we are done with echoing all =
the data,=20
we should close this socket; the parent server socket stays around to =
spawn new=20
children, like the one just closed. </P>
<H3>A TCP echo server (configuring the server socket)</H3>
<P>As we outlined before, creating a socket has a bit different purpose =
for a=20
server than for a client. Creating the socket has the same syntax it did =
in the=20
client; but the structure <CODE>echoserver</CODE> is setup with =
information=20
about the server itself, rather than about the peer it wants to connect =
to. You=20
usually want to use the special constant <CODE>INADDR_ANY</CODE> to =
enable=20
receiving client request on any IP address the server supplies; in =
principle,=20
such as in a multi-hosting server, you could specify a particular IP =
address=20
instead. </P><PRE>=20
          int main(int argc, char *argv[]) {
            int serversock, clientsock;
            struct sockaddr_in echoserver, echoclient;

            if (argc !=3D 2) {
              fprintf(stderr, "USAGE: echoserver &lt;port&gt;\n");
              exit(1);
            }
            /* Create the TCP socket */
            if ((serversock =3D socket(PF_INET, SOCK_STREAM, =
IPPROTO_TCP)) &lt; 0) {
              Die("Failed to create socket");
            }
            /* Construct the server sockaddr_in structure */
            memset(&amp;echoserver, 0, sizeof(echoserver));       /* =
Clear struct */
            echoserver.sin_family =3D AF_INET;                  /* =
Internet/IP */
            echoserver.sin_addr.s_addr =3D htonl(INADDR_ANY);   /* =
Incoming addr */
            echoserver.sin_port =3D htons(atoi(argv[1]));       /* =
server port */
           </PRE>
<P>Notice that both IP address and port are converted to network byte =
order for=20
the <CODE>sockaddr_in</CODE> structure. The reverse functions to return =
to=20
native byte order are <CODE>ntohs()</CODE> and <CODE>ntohl()</CODE> . =
These=20
functions are no-ops on some platforms, but it is still wise to use them =
for=20
cross-platform compatibility. </P>
<H3>A TCP echo server (binding and listening)</H3>
<P>Whereas the client application <CODE>connect()</CODE> 'd to a =
server's IP=20
address and port, the server <CODE>bind()</CODE> 's to its own address =
and port:=20
</P><PRE>=20
          /* Bind the server socket */
          if (bind(serversock, (struct sockaddr *) &amp;echoserver,
                                       sizeof(echoserver)) &lt; 0) {
            Die("Failed to bind the server socket");
          }
          /* Listen on the server socket */
          if (listen(serversock, MAXPENDING) &lt; 0) {
            Die("Failed to listen on server socket");
          }
           </PRE>
<P>Once the server socket is bound, it is ready to <CODE>listen()</CODE> =
. As=20
with most socket functions, both <CODE>bind()</CODE> and =
<CODE>listen()</CODE>=20
return -1 if they have a problem. Once a server socket is listening, it =
is ready=20
to <CODE>accept()</CODE> client connections, acting as a factory for =
sockets on=20
each connection. </P>
<H3>A TCP echo server (socket factory)</H3>
<P>Creating new sockets for client connections is the crux of a server. =
The=20
function <CODE>accept()</CODE> does two important things: it returns a =
socket=20
pointer for the new socket; and it populates the =
<CODE>sockaddr_in</CODE>=20
structure pointed to, in our case, by <CODE>echoclient</CODE> . =
</P><PRE>=20
            /* Run until cancelled */
            while (1) {
              unsigned int clientlen =3D sizeof(echoclient);
              /* Wait for client connection */
              if ((clientsock =3D
                   accept(serversock, (struct sockaddr *) =
&amp;echoclient,
                          &amp;clientlen)) &lt; 0) {
                Die("Failed to accept client connection");
              }
              fprintf(stdout, "Client connected: %s\n",
                              inet_ntoa(echoclient.sin_addr));
              HandleClient(clientsock);
            }
          }
           </PRE>
<P>We can see the populated structure in <CODE>echoclient</CODE> with =
the=20
<CODE>fprintf()</CODE> call that accesses the client IP address. The =
client=20
socket pointer is passed to <CODE>HandleClient()</CODE> , which we saw =
at the=20
start of this section. </P>
<HR>

<H2 align=3Dcenter>Writing Socket Applications in Python</H2>
<HR>

<H3>The socket and SocketServer module</H3>
<P>Python's standard module <CODE>socket</CODE> provides almost exactly =
the same=20
range of capabilities you would find in C sockets. However, the =
interface is=20
generally more flexible, largely because of the benefits of dynamic =
typing.=20
Moreover, an object-oriented style is also used. For example, once you =
create a=20
socket object, methods like <CODE>.bind()</CODE> , =
<CODE>.connect()</CODE> , and=20
<CODE>.send()</CODE> are methods of that object, rather than global =
functions=20
operating on a socket pointer. </P>
<P>At a higher level than <CODE>socket</CODE> , the module=20
<CODE>SocketServer</CODE> provides a framework for writing servers. This =
is=20
still relatively low level, and higher-level interfaces are available =
for server=20
of higher-level protocols, e.g. <CODE>SimpleHTTPServer</CODE> ,=20
<CODE>DocXMLRPCServer</CODE> , or <CODE>CGIHTTPServer</CODE> . </P>
<H3>A Python TCP echo client</H3>
<P>Let us just look at the complete client, then make a few remarks: =
</P><PRE>=20
          #!/usr/bin/env python
          "USAGE: echoclient.py &lt;server&gt; &lt;word&gt; =
&lt;port&gt;"
          from socket import *    # import *, but we'll avoid name =
conflict
          import sys
          if len(sys.argv) !=3D 4:
              print __doc__
              sys.exit(0)
          sock =3D socket(AF_INET, SOCK_STREAM)
          sock.connect((sys.argv[1], int(sys.argv[3])))
          message =3D sys.argv[2]
          messlen, received =3D sock.send(message), 0
          if messlen !=3D len(message):
              print "Failed to send complete message"
          print "Received: ",
          while received &lt; messlen:
              data =3D sock.recv(32)
              sys.stdout.write(data)
              received +=3D len(data)
          print
          sock.close()
           </PRE>
<P>At first brush, we seem to have left out some of the error catching =
code from=20
the C version. But since Python raises descriptive errors for every =
situation=20
that we checked for in the C echo client, we can let the built-in =
exceptions do=20
our work for us. Of course, if we wanted the precise wording of errors =
that we=20
had before, we would have to add a few <CODE>try</CODE> / =
<CODE>except</CODE>=20
clauses around the calls to methods of the socket object. </P>
<H3>A Python TCP echo client, continued</H3>
<P>While shorter, the Python client is somewhat more powerful. =
Specifically, the=20
address we feed to a <CODE>.connect()</CODE> call can be either a =
dotted-quad IP=20
address or a symbolic name, without need for extra lookup work, e.g.: =
</P><PRE>=20
          $ ./echoclient.py 192.168.2.103 foobar 7
          Received: foobar
          $ ./echoclient.py fury.gnosis.lan foobar 7
          Received: foobar
           </PRE>
<P>We also have a choice between the methods <CODE>.send()</CODE> and=20
<CODE>.sendall()</CODE> . The former sends as many bytes as it can at =
once, the=20
latter sends the whole message (or raises an exception if it cannot). =
For this=20
client, we indicate if the whole message was not sent, but proceed with =
getting=20
back as much as actually was sent. </P>
<H3>A Python TCP echo server (SocketServer)</H3>
<P>The simplest way to write a echo server in Python is using the=20
<CODE>SocketServer</CODE> module. It is so easy as to almost seem like =
cheating.=20
In later panels, we will spell out the lower-level version, that follows =
the C=20
implementation. For now, let us see just how quick it can be: </P><PRE>=20
          #!/usr/bin/env python
          "USAGE: echoserver.py &lt;port&gt;"
          from SocketServer import BaseRequestHandler, TCPServer
          import sys, socket

          class EchoHandler(BaseRequestHandler):
              def handle(self):
                  print "Client connected:", self.client_address
                  self.request.sendall(self.request.recv(2**16))
                  self.request.close()

          if len(sys.argv) !=3D 2:
              print __doc__
          else:
              TCPServer(('',int(sys.argv[1])), =
EchoHandler).serve_forever()
           </PRE>
<P>The only thing we need to provide is a child of=20
<CODE>SocketServer.BaseRequestHandler</CODE> that has a =
<CODE>.handle()</CODE>=20
method. The <CODE>self</CODE> instance has some useful attributes, such =
as=20
<CODE>.client_address</CODE> , and <CODE>.request</CODE> which is itself =
a=20
connected socket object. </P>
<H3>A Python TCP echo server (socket)</H3>
<P>If we wish to do it "the hard way"--and gain a bit more fine-tuned =
control,=20
we can write almost exactly our C echo server in Python (but in fewer =
lines):=20
</P><PRE>=20
          #!/usr/bin/env python
          "USAGE: echoserver.py &lt;port&gt;"
          from socket import *    # import *, but we'll avoid name =
conflict
          import sys

          def handleClient(sock):
              data =3D sock.recv(32)
              while data:
                  sock.sendall(data)
                  data =3D sock.recv(32)
              sock.close()

          if len(sys.argv) !=3D 2:
              print __doc__
          else:
              sock =3D socket(AF_INET, SOCK_STREAM)
              sock.bind(('',int(sys.argv[1])))
              sock.listen(5)
              while 1:    # Run until cancelled
                  newsock, client_addr =3D sock.accept()
                  print "Client connected:", client_addr
                  handleClient(newsock)
           </PRE>
<P>In truth, this "hard way" still isn't very hard. But as in the C=20
implementation, we manufacture new connected sockets using=20
<CODE>.listen()</CODE> , and call our handler for each such connection. =
</P>
<HR>

<H2 align=3Dcenter>Summary and resources</H2>
<HR>

<H3>Summary</H3>
<P>The server and client presented in this tutorial are simple, but they =
show=20
everything essential to writing TCP sockets applications. If the data=20
transmitted is more complicated, or the interaction between peers =
(client and=20
server) is ore sophisticated in your application, that is just a matter =
of=20
additional application programming. The data exchanged will still follow =
the=20
same pattern of <CODE>connect()</CODE> and <CODE>bind()</CODE> , then=20
<CODE>send()</CODE> 's and <CODE>recv()</CODE> 's. </P>
<P>One thing this tutorial did not get to, except in brief summary at =
the start,=20
is usage of UDP sockets. TCP is more common, but it is important to also =

understand UDP sockets as an option for your application. Part two of =
this=20
tutorial will look at UDP, as well as implementing sockets applications =
in=20
Python, and some other intermediate topics. </P>
<H3>Resources</H3>
<P>A good introduction to sockets programming in C, is Michael J. =
Donahoo and=20
Kenneth L. Calvert, <I>TCP/IP Sockets in C</I> , Morgan-Kaufmann, 2001; =
ISBN:=20
1-55860-826-5. </P>
<H3>Feedback</H3>
<P>Please let us know whether this tutorial was helpful to you and how =
we could=20
make it better. We'd also like to hear about other tutorial topics you'd =
like to=20
see covered. </P>
<P>For questions about the content of this tutorial, contact the author, =
David=20
Mertz, at <A>mertz@gnosis.cx</A> . </P></BODY></HTML>

------=_NextPart_000_0000_01C93B7F.D7E2CC20
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: http://gnosis.cx/publish/programming/network-layers.png

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

------=_NextPart_000_0000_01C93B7F.D7E2CC20--
